// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-sdks/northflank-go/pkg/types"
	"github.com/speakeasy-sdks/northflank-go/pkg/utils"
)

// LogSinkRequestSinkData7 - Honeycomb Sink Schema.
type LogSinkRequestSinkData7 struct {
	// Honeycomb API Key
	APIKey string `json:"api_key"`
	// Name of the dataset
	Dataset string `json:"dataset"`
}

func (o *LogSinkRequestSinkData7) GetAPIKey() string {
	if o == nil {
		return ""
	}
	return o.APIKey
}

func (o *LogSinkRequestSinkData7) GetDataset() string {
	if o == nil {
		return ""
	}
	return o.Dataset
}

// LogSinkRequestSinkData6 - LogDNA Sink Schema.
type LogSinkRequestSinkData6 struct {
	// Ingestion Key
	APIKey string `json:"api_key"`
}

func (o *LogSinkRequestSinkData6) GetAPIKey() string {
	if o == nil {
		return ""
	}
	return o.APIKey
}

// LogSinkRequestSinkData5 - Logtail Sink Schema.
type LogSinkRequestSinkData5 struct {
	// Logtail Source Token
	Token string `json:"token"`
}

func (o *LogSinkRequestSinkData5) GetToken() string {
	if o == nil {
		return ""
	}
	return o.Token
}

// LogSinkRequestSinkData4Auth - Authentication object.
type LogSinkRequestSinkData4Auth struct {
	// Access key id for the bucket.
	AccessKeyID string `json:"accessKeyId"`
	// Secret access key for the bucket.
	SecretAccessKey string `json:"secretAccessKey"`
}

func (o *LogSinkRequestSinkData4Auth) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *LogSinkRequestSinkData4Auth) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

// LogSinkRequestSinkData4Compression - Log file compression method.
type LogSinkRequestSinkData4Compression string

const (
	LogSinkRequestSinkData4CompressionGzip LogSinkRequestSinkData4Compression = "gzip"
	LogSinkRequestSinkData4CompressionNone LogSinkRequestSinkData4Compression = "none"
)

func (e LogSinkRequestSinkData4Compression) ToPointer() *LogSinkRequestSinkData4Compression {
	return &e
}

func (e *LogSinkRequestSinkData4Compression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = LogSinkRequestSinkData4Compression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSinkData4Compression: %v", v)
	}
}

// LogSinkRequestSinkData4Region - Region of the S3 bucket.
type LogSinkRequestSinkData4Region string

const (
	LogSinkRequestSinkData4RegionEuWest1    LogSinkRequestSinkData4Region = "eu-west-1"
	LogSinkRequestSinkData4RegionEuWest2    LogSinkRequestSinkData4Region = "eu-west-2"
	LogSinkRequestSinkData4RegionEuWest3    LogSinkRequestSinkData4Region = "eu-west-3"
	LogSinkRequestSinkData4RegionEuCentral1 LogSinkRequestSinkData4Region = "eu-central-1"
	LogSinkRequestSinkData4RegionEuSouth1   LogSinkRequestSinkData4Region = "eu-south-1"
	LogSinkRequestSinkData4RegionEuNorth1   LogSinkRequestSinkData4Region = "eu-north-1"
	LogSinkRequestSinkData4RegionUsWest1    LogSinkRequestSinkData4Region = "us-west-1"
	LogSinkRequestSinkData4RegionUsWest2    LogSinkRequestSinkData4Region = "us-west-2"
	LogSinkRequestSinkData4RegionUsEast1    LogSinkRequestSinkData4Region = "us-east-1"
	LogSinkRequestSinkData4RegionUsEast2    LogSinkRequestSinkData4Region = "us-east2"
)

func (e LogSinkRequestSinkData4Region) ToPointer() *LogSinkRequestSinkData4Region {
	return &e
}

func (e *LogSinkRequestSinkData4Region) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east2":
		*e = LogSinkRequestSinkData4Region(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSinkData4Region: %v", v)
	}
}

// LogSinkRequestSinkData4 - AWS S3 or compatible API Sink Schema.
type LogSinkRequestSinkData4 struct {
	// Authentication object.
	Auth *LogSinkRequestSinkData4Auth `json:"auth,omitempty"`
	// Name of the S3 Bucket.
	Bucket string `json:"bucket"`
	// Log file compression method.
	Compression LogSinkRequestSinkData4Compression `json:"compression"`
	// Endpoint for the AWS S3 or compatible API bucket.
	Endpoint string `json:"endpoint"`
	// Region of the S3 bucket.
	Region LogSinkRequestSinkData4Region `json:"region"`
}

func (o *LogSinkRequestSinkData4) GetAuth() *LogSinkRequestSinkData4Auth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *LogSinkRequestSinkData4) GetBucket() string {
	if o == nil {
		return ""
	}
	return o.Bucket
}

func (o *LogSinkRequestSinkData4) GetCompression() LogSinkRequestSinkData4Compression {
	if o == nil {
		return LogSinkRequestSinkData4Compression("")
	}
	return o.Compression
}

func (o *LogSinkRequestSinkData4) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *LogSinkRequestSinkData4) GetRegion() LogSinkRequestSinkData4Region {
	if o == nil {
		return LogSinkRequestSinkData4Region("")
	}
	return o.Region
}

// LogSinkRequestSinkData3Auth3 - Authenticate with a bearer token strategy.
type LogSinkRequestSinkData3Auth3 struct {
	// Bearer token authentication strategy.
	strategy string `const:"bearer" json:"strategy"`
	// Token for bearer token authentication.
	Token *string `json:"token,omitempty"`
}

func (l LogSinkRequestSinkData3Auth3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkRequestSinkData3Auth3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkRequestSinkData3Auth3) GetStrategy() string {
	return "bearer"
}

func (o *LogSinkRequestSinkData3Auth3) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

// LogSinkRequestSinkData3Auth2 - Authenticate with a basic http strategy.
type LogSinkRequestSinkData3Auth2 struct {
	// Password for basic http authentication.
	Password string `json:"password"`
	// Basic HTTP authentication strategy.
	strategy string `const:"basic" json:"strategy"`
	// Username for basic http authentication.
	User *string `json:"user,omitempty"`
}

func (l LogSinkRequestSinkData3Auth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkRequestSinkData3Auth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkRequestSinkData3Auth2) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *LogSinkRequestSinkData3Auth2) GetStrategy() string {
	return "basic"
}

func (o *LogSinkRequestSinkData3Auth2) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

// LogSinkRequestSinkData3Auth1 - No authentication strategy
type LogSinkRequestSinkData3Auth1 struct {
	// No authentication strategy
	strategy string `const:"none" json:"strategy"`
}

func (l LogSinkRequestSinkData3Auth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkRequestSinkData3Auth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkRequestSinkData3Auth1) GetStrategy() string {
	return "none"
}

type LogSinkRequestSinkData3AuthType string

const (
	LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth1 LogSinkRequestSinkData3AuthType = "LogSinkRequest_sinkData_3_auth_1"
	LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth2 LogSinkRequestSinkData3AuthType = "LogSinkRequest_sinkData_3_auth_2"
	LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth3 LogSinkRequestSinkData3AuthType = "LogSinkRequest_sinkData_3_auth_3"
)

type LogSinkRequestSinkData3Auth struct {
	LogSinkRequestSinkData3Auth1 *LogSinkRequestSinkData3Auth1
	LogSinkRequestSinkData3Auth2 *LogSinkRequestSinkData3Auth2
	LogSinkRequestSinkData3Auth3 *LogSinkRequestSinkData3Auth3

	Type LogSinkRequestSinkData3AuthType
}

func CreateLogSinkRequestSinkData3AuthLogSinkRequestSinkData3Auth1(logSinkRequestSinkData3Auth1 LogSinkRequestSinkData3Auth1) LogSinkRequestSinkData3Auth {
	typ := LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth1

	return LogSinkRequestSinkData3Auth{
		LogSinkRequestSinkData3Auth1: &logSinkRequestSinkData3Auth1,
		Type:                         typ,
	}
}

func CreateLogSinkRequestSinkData3AuthLogSinkRequestSinkData3Auth2(logSinkRequestSinkData3Auth2 LogSinkRequestSinkData3Auth2) LogSinkRequestSinkData3Auth {
	typ := LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth2

	return LogSinkRequestSinkData3Auth{
		LogSinkRequestSinkData3Auth2: &logSinkRequestSinkData3Auth2,
		Type:                         typ,
	}
}

func CreateLogSinkRequestSinkData3AuthLogSinkRequestSinkData3Auth3(logSinkRequestSinkData3Auth3 LogSinkRequestSinkData3Auth3) LogSinkRequestSinkData3Auth {
	typ := LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth3

	return LogSinkRequestSinkData3Auth{
		LogSinkRequestSinkData3Auth3: &logSinkRequestSinkData3Auth3,
		Type:                         typ,
	}
}

func (u *LogSinkRequestSinkData3Auth) UnmarshalJSON(data []byte) error {

	logSinkRequestSinkData3Auth1 := new(LogSinkRequestSinkData3Auth1)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData3Auth1, "", true, true); err == nil {
		u.LogSinkRequestSinkData3Auth1 = logSinkRequestSinkData3Auth1
		u.Type = LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth1
		return nil
	}

	logSinkRequestSinkData3Auth3 := new(LogSinkRequestSinkData3Auth3)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData3Auth3, "", true, true); err == nil {
		u.LogSinkRequestSinkData3Auth3 = logSinkRequestSinkData3Auth3
		u.Type = LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth3
		return nil
	}

	logSinkRequestSinkData3Auth2 := new(LogSinkRequestSinkData3Auth2)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData3Auth2, "", true, true); err == nil {
		u.LogSinkRequestSinkData3Auth2 = logSinkRequestSinkData3Auth2
		u.Type = LogSinkRequestSinkData3AuthTypeLogSinkRequestSinkData3Auth2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LogSinkRequestSinkData3Auth) MarshalJSON() ([]byte, error) {
	if u.LogSinkRequestSinkData3Auth1 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData3Auth1, "", true)
	}

	if u.LogSinkRequestSinkData3Auth2 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData3Auth2, "", true)
	}

	if u.LogSinkRequestSinkData3Auth3 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData3Auth3, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// LogSinkRequestSinkData3EncodingCodec - Codec to encode logs in
type LogSinkRequestSinkData3EncodingCodec string

const (
	LogSinkRequestSinkData3EncodingCodecText LogSinkRequestSinkData3EncodingCodec = "text"
	LogSinkRequestSinkData3EncodingCodecJSON LogSinkRequestSinkData3EncodingCodec = "json"
)

func (e LogSinkRequestSinkData3EncodingCodec) ToPointer() *LogSinkRequestSinkData3EncodingCodec {
	return &e
}

func (e *LogSinkRequestSinkData3EncodingCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "json":
		*e = LogSinkRequestSinkData3EncodingCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSinkData3EncodingCodec: %v", v)
	}
}

// LogSinkRequestSinkData3Encoding - Encoding options
type LogSinkRequestSinkData3Encoding struct {
	// Codec to encode logs in
	Codec LogSinkRequestSinkData3EncodingCodec `json:"codec"`
}

func (o *LogSinkRequestSinkData3Encoding) GetCodec() LogSinkRequestSinkData3EncodingCodec {
	if o == nil {
		return LogSinkRequestSinkData3EncodingCodec("")
	}
	return o.Codec
}

// LogSinkRequestSinkData3 - HTTP Sink Schema.
type LogSinkRequestSinkData3 struct {
	Auth LogSinkRequestSinkData3Auth `json:"auth"`
	// Encoding options
	Encoding *LogSinkRequestSinkData3Encoding `json:"encoding,omitempty"`
	// Uri to send logs to.
	URI string `json:"uri"`
}

func (o *LogSinkRequestSinkData3) GetAuth() LogSinkRequestSinkData3Auth {
	if o == nil {
		return LogSinkRequestSinkData3Auth{}
	}
	return o.Auth
}

func (o *LogSinkRequestSinkData3) GetEncoding() *LogSinkRequestSinkData3Encoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *LogSinkRequestSinkData3) GetURI() string {
	if o == nil {
		return ""
	}
	return o.URI
}

// LogSinkRequestSinkData2Region - The Datadog region.
type LogSinkRequestSinkData2Region string

const (
	LogSinkRequestSinkData2RegionEu  LogSinkRequestSinkData2Region = "eu"
	LogSinkRequestSinkData2RegionUs  LogSinkRequestSinkData2Region = "us"
	LogSinkRequestSinkData2RegionUs3 LogSinkRequestSinkData2Region = "us3"
	LogSinkRequestSinkData2RegionUs5 LogSinkRequestSinkData2Region = "us5"
)

func (e LogSinkRequestSinkData2Region) ToPointer() *LogSinkRequestSinkData2Region {
	return &e
}

func (e *LogSinkRequestSinkData2Region) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "us3":
		fallthrough
	case "us5":
		*e = LogSinkRequestSinkData2Region(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSinkData2Region: %v", v)
	}
}

// LogSinkRequestSinkData2 - Datadog Sink Schema.
type LogSinkRequestSinkData2 struct {
	// The Datadog API key.
	DefaultAPIKey *string `json:"default_api_key,omitempty"`
	// The Datadog region.
	Region *LogSinkRequestSinkData2Region `json:"region,omitempty"`
}

func (o *LogSinkRequestSinkData2) GetDefaultAPIKey() *string {
	if o == nil {
		return nil
	}
	return o.DefaultAPIKey
}

func (o *LogSinkRequestSinkData2) GetRegion() *LogSinkRequestSinkData2Region {
	if o == nil {
		return nil
	}
	return o.Region
}

// LogSinkRequestSinkData1Auth - Object containing authentication data for the log sink.
type LogSinkRequestSinkData1Auth struct {
	// The password for the log sink.
	Password *string `json:"password,omitempty"`
	// The authentication method.
	strategy *string `const:"basic" json:"strategy,omitempty"`
	// The username for the log sink.
	User *string `json:"user,omitempty"`
}

func (l LogSinkRequestSinkData1Auth) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkRequestSinkData1Auth) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkRequestSinkData1Auth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *LogSinkRequestSinkData1Auth) GetStrategy() *string {
	return types.String("basic")
}

func (o *LogSinkRequestSinkData1Auth) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

// LogSinkRequestSinkData1 - Loki Sink Schema.
type LogSinkRequestSinkData1 struct {
	// Object containing authentication data for the log sink.
	Auth *LogSinkRequestSinkData1Auth `json:"auth,omitempty"`
	// The endpoint of the Loki log sink.
	Endpoint *string `json:"endpoint,omitempty"`
}

func (o *LogSinkRequestSinkData1) GetAuth() *LogSinkRequestSinkData1Auth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *LogSinkRequestSinkData1) GetEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.Endpoint
}

type LogSinkRequestSinkDataType string

const (
	LogSinkRequestSinkDataTypeLogSinkRequestSinkData1 LogSinkRequestSinkDataType = "LogSinkRequest_sinkData_1"
	LogSinkRequestSinkDataTypeLogSinkRequestSinkData2 LogSinkRequestSinkDataType = "LogSinkRequest_sinkData_2"
	LogSinkRequestSinkDataTypeLogSinkRequestSinkData3 LogSinkRequestSinkDataType = "LogSinkRequest_sinkData_3"
	LogSinkRequestSinkDataTypeLogSinkRequestSinkData4 LogSinkRequestSinkDataType = "LogSinkRequest_sinkData_4"
	LogSinkRequestSinkDataTypeLogSinkRequestSinkData5 LogSinkRequestSinkDataType = "LogSinkRequest_sinkData_5"
	LogSinkRequestSinkDataTypeLogSinkRequestSinkData6 LogSinkRequestSinkDataType = "LogSinkRequest_sinkData_6"
	LogSinkRequestSinkDataTypeLogSinkRequestSinkData7 LogSinkRequestSinkDataType = "LogSinkRequest_sinkData_7"
)

type LogSinkRequestSinkData struct {
	LogSinkRequestSinkData1 *LogSinkRequestSinkData1
	LogSinkRequestSinkData2 *LogSinkRequestSinkData2
	LogSinkRequestSinkData3 *LogSinkRequestSinkData3
	LogSinkRequestSinkData4 *LogSinkRequestSinkData4
	LogSinkRequestSinkData5 *LogSinkRequestSinkData5
	LogSinkRequestSinkData6 *LogSinkRequestSinkData6
	LogSinkRequestSinkData7 *LogSinkRequestSinkData7

	Type LogSinkRequestSinkDataType
}

func CreateLogSinkRequestSinkDataLogSinkRequestSinkData1(logSinkRequestSinkData1 LogSinkRequestSinkData1) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeLogSinkRequestSinkData1

	return LogSinkRequestSinkData{
		LogSinkRequestSinkData1: &logSinkRequestSinkData1,
		Type:                    typ,
	}
}

func CreateLogSinkRequestSinkDataLogSinkRequestSinkData2(logSinkRequestSinkData2 LogSinkRequestSinkData2) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeLogSinkRequestSinkData2

	return LogSinkRequestSinkData{
		LogSinkRequestSinkData2: &logSinkRequestSinkData2,
		Type:                    typ,
	}
}

func CreateLogSinkRequestSinkDataLogSinkRequestSinkData3(logSinkRequestSinkData3 LogSinkRequestSinkData3) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeLogSinkRequestSinkData3

	return LogSinkRequestSinkData{
		LogSinkRequestSinkData3: &logSinkRequestSinkData3,
		Type:                    typ,
	}
}

func CreateLogSinkRequestSinkDataLogSinkRequestSinkData4(logSinkRequestSinkData4 LogSinkRequestSinkData4) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeLogSinkRequestSinkData4

	return LogSinkRequestSinkData{
		LogSinkRequestSinkData4: &logSinkRequestSinkData4,
		Type:                    typ,
	}
}

func CreateLogSinkRequestSinkDataLogSinkRequestSinkData5(logSinkRequestSinkData5 LogSinkRequestSinkData5) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeLogSinkRequestSinkData5

	return LogSinkRequestSinkData{
		LogSinkRequestSinkData5: &logSinkRequestSinkData5,
		Type:                    typ,
	}
}

func CreateLogSinkRequestSinkDataLogSinkRequestSinkData6(logSinkRequestSinkData6 LogSinkRequestSinkData6) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeLogSinkRequestSinkData6

	return LogSinkRequestSinkData{
		LogSinkRequestSinkData6: &logSinkRequestSinkData6,
		Type:                    typ,
	}
}

func CreateLogSinkRequestSinkDataLogSinkRequestSinkData7(logSinkRequestSinkData7 LogSinkRequestSinkData7) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeLogSinkRequestSinkData7

	return LogSinkRequestSinkData{
		LogSinkRequestSinkData7: &logSinkRequestSinkData7,
		Type:                    typ,
	}
}

func (u *LogSinkRequestSinkData) UnmarshalJSON(data []byte) error {

	logSinkRequestSinkData5 := new(LogSinkRequestSinkData5)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData5, "", true, true); err == nil {
		u.LogSinkRequestSinkData5 = logSinkRequestSinkData5
		u.Type = LogSinkRequestSinkDataTypeLogSinkRequestSinkData5
		return nil
	}

	logSinkRequestSinkData6 := new(LogSinkRequestSinkData6)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData6, "", true, true); err == nil {
		u.LogSinkRequestSinkData6 = logSinkRequestSinkData6
		u.Type = LogSinkRequestSinkDataTypeLogSinkRequestSinkData6
		return nil
	}

	logSinkRequestSinkData1 := new(LogSinkRequestSinkData1)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData1, "", true, true); err == nil {
		u.LogSinkRequestSinkData1 = logSinkRequestSinkData1
		u.Type = LogSinkRequestSinkDataTypeLogSinkRequestSinkData1
		return nil
	}

	logSinkRequestSinkData2 := new(LogSinkRequestSinkData2)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData2, "", true, true); err == nil {
		u.LogSinkRequestSinkData2 = logSinkRequestSinkData2
		u.Type = LogSinkRequestSinkDataTypeLogSinkRequestSinkData2
		return nil
	}

	logSinkRequestSinkData7 := new(LogSinkRequestSinkData7)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData7, "", true, true); err == nil {
		u.LogSinkRequestSinkData7 = logSinkRequestSinkData7
		u.Type = LogSinkRequestSinkDataTypeLogSinkRequestSinkData7
		return nil
	}

	logSinkRequestSinkData3 := new(LogSinkRequestSinkData3)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData3, "", true, true); err == nil {
		u.LogSinkRequestSinkData3 = logSinkRequestSinkData3
		u.Type = LogSinkRequestSinkDataTypeLogSinkRequestSinkData3
		return nil
	}

	logSinkRequestSinkData4 := new(LogSinkRequestSinkData4)
	if err := utils.UnmarshalJSON(data, &logSinkRequestSinkData4, "", true, true); err == nil {
		u.LogSinkRequestSinkData4 = logSinkRequestSinkData4
		u.Type = LogSinkRequestSinkDataTypeLogSinkRequestSinkData4
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LogSinkRequestSinkData) MarshalJSON() ([]byte, error) {
	if u.LogSinkRequestSinkData1 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData1, "", true)
	}

	if u.LogSinkRequestSinkData2 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData2, "", true)
	}

	if u.LogSinkRequestSinkData3 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData3, "", true)
	}

	if u.LogSinkRequestSinkData4 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData4, "", true)
	}

	if u.LogSinkRequestSinkData5 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData5, "", true)
	}

	if u.LogSinkRequestSinkData6 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData6, "", true)
	}

	if u.LogSinkRequestSinkData7 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSinkData7, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type LogSinkRequest struct {
	// If `restricted` is `true`, only logs from these projects will be sent to the log sink.
	Projects []string `json:"projects,omitempty"`
	// If `true`, only logs from the projects in `projects` will be sent to the log sink.
	Restricted *bool `json:"restricted,omitempty"`
	// If `true`, and the log sink is currently paused, the log sink will be resumed after updating.
	ResumeLogSink *bool `default:"false" json:"resumeLogSink"`
	// Data about the log sink.
	SinkData *LogSinkRequestSinkData `json:"sinkData,omitempty"`
	// If `true`, we will do additional parsing on your JSON formatted log lines and your extract custom labels
	UseCustomLabels *bool `default:"false" json:"useCustomLabels"`
}

func (l LogSinkRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkRequest) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *LogSinkRequest) GetRestricted() *bool {
	if o == nil {
		return nil
	}
	return o.Restricted
}

func (o *LogSinkRequest) GetResumeLogSink() *bool {
	if o == nil {
		return nil
	}
	return o.ResumeLogSink
}

func (o *LogSinkRequest) GetSinkData() *LogSinkRequestSinkData {
	if o == nil {
		return nil
	}
	return o.SinkData
}

func (o *LogSinkRequest) GetUseCustomLabels() *bool {
	if o == nil {
		return nil
	}
	return o.UseCustomLabels
}
