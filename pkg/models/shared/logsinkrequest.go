// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-sdks/northflank-go/v2/pkg/utils"
)

// Eight - Honeycomb Sink Schema.
type Eight struct {
	// Honeycomb API Key
	APIKey string `json:"api_key"`
	// Name of the dataset
	Dataset string `json:"dataset"`
}

func (o *Eight) GetAPIKey() string {
	if o == nil {
		return ""
	}
	return o.APIKey
}

func (o *Eight) GetDataset() string {
	if o == nil {
		return ""
	}
	return o.Dataset
}

// Seven - LogDNA Sink Schema.
type Seven struct {
	// Ingestion Key
	APIKey string `json:"api_key"`
}

func (o *Seven) GetAPIKey() string {
	if o == nil {
		return ""
	}
	return o.APIKey
}

// Six - Logtail Sink Schema.
type Six struct {
	// Logtail Source Token
	Token string `json:"token"`
}

func (o *Six) GetToken() string {
	if o == nil {
		return ""
	}
	return o.Token
}

// LogSinkRequestSchemasSinkDataAuth - Authentication object.
type LogSinkRequestSchemasSinkDataAuth struct {
	// Access key id for the bucket.
	AccessKeyID string `json:"accessKeyId"`
	// Secret access key for the bucket.
	SecretAccessKey string `json:"secretAccessKey"`
}

func (o *LogSinkRequestSchemasSinkDataAuth) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *LogSinkRequestSchemasSinkDataAuth) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

// LogSinkRequestCompression - Log file compression method.
type LogSinkRequestCompression string

const (
	LogSinkRequestCompressionGzip LogSinkRequestCompression = "gzip"
	LogSinkRequestCompressionNone LogSinkRequestCompression = "none"
)

func (e LogSinkRequestCompression) ToPointer() *LogSinkRequestCompression {
	return &e
}

func (e *LogSinkRequestCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = LogSinkRequestCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestCompression: %v", v)
	}
}

// LogSinkRequestSchemasRegion - Region of the S3 bucket.
type LogSinkRequestSchemasRegion string

const (
	LogSinkRequestSchemasRegionEuWest1    LogSinkRequestSchemasRegion = "eu-west-1"
	LogSinkRequestSchemasRegionEuWest2    LogSinkRequestSchemasRegion = "eu-west-2"
	LogSinkRequestSchemasRegionEuWest3    LogSinkRequestSchemasRegion = "eu-west-3"
	LogSinkRequestSchemasRegionEuCentral1 LogSinkRequestSchemasRegion = "eu-central-1"
	LogSinkRequestSchemasRegionEuSouth1   LogSinkRequestSchemasRegion = "eu-south-1"
	LogSinkRequestSchemasRegionEuNorth1   LogSinkRequestSchemasRegion = "eu-north-1"
	LogSinkRequestSchemasRegionUsWest1    LogSinkRequestSchemasRegion = "us-west-1"
	LogSinkRequestSchemasRegionUsWest2    LogSinkRequestSchemasRegion = "us-west-2"
	LogSinkRequestSchemasRegionUsEast1    LogSinkRequestSchemasRegion = "us-east-1"
	LogSinkRequestSchemasRegionUsEast2    LogSinkRequestSchemasRegion = "us-east2"
)

func (e LogSinkRequestSchemasRegion) ToPointer() *LogSinkRequestSchemasRegion {
	return &e
}

func (e *LogSinkRequestSchemasRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east2":
		*e = LogSinkRequestSchemasRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSchemasRegion: %v", v)
	}
}

// Five - AWS S3 or compatible API Sink Schema.
type Five struct {
	// Authentication object.
	Auth *LogSinkRequestSchemasSinkDataAuth `json:"auth,omitempty"`
	// Name of the S3 Bucket.
	Bucket string `json:"bucket"`
	// Log file compression method.
	Compression LogSinkRequestCompression `json:"compression"`
	// Endpoint for the AWS S3 or compatible API bucket.
	Endpoint string `json:"endpoint"`
	// Region of the S3 bucket.
	Region LogSinkRequestSchemasRegion `json:"region"`
}

func (o *Five) GetAuth() *LogSinkRequestSchemasSinkDataAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *Five) GetBucket() string {
	if o == nil {
		return ""
	}
	return o.Bucket
}

func (o *Five) GetCompression() LogSinkRequestCompression {
	if o == nil {
		return LogSinkRequestCompression("")
	}
	return o.Compression
}

func (o *Five) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *Five) GetRegion() LogSinkRequestSchemasRegion {
	if o == nil {
		return LogSinkRequestSchemasRegion("")
	}
	return o.Region
}

// LogSinkRequestSchemasSinkData4Strategy - Bearer token authentication strategy.
type LogSinkRequestSchemasSinkData4Strategy string

const (
	LogSinkRequestSchemasSinkData4StrategyBearer LogSinkRequestSchemasSinkData4Strategy = "bearer"
)

func (e LogSinkRequestSchemasSinkData4Strategy) ToPointer() *LogSinkRequestSchemasSinkData4Strategy {
	return &e
}

func (e *LogSinkRequestSchemasSinkData4Strategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bearer":
		*e = LogSinkRequestSchemasSinkData4Strategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSchemasSinkData4Strategy: %v", v)
	}
}

// LogSinkRequest3 - Authenticate with a bearer token strategy.
type LogSinkRequest3 struct {
	// Bearer token authentication strategy.
	Strategy LogSinkRequestSchemasSinkData4Strategy `json:"strategy"`
	// Token for bearer token authentication.
	Token *string `json:"token,omitempty"`
}

func (o *LogSinkRequest3) GetStrategy() LogSinkRequestSchemasSinkData4Strategy {
	if o == nil {
		return LogSinkRequestSchemasSinkData4Strategy("")
	}
	return o.Strategy
}

func (o *LogSinkRequest3) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

// LogSinkRequestSchemasSinkDataStrategy - Basic HTTP authentication strategy.
type LogSinkRequestSchemasSinkDataStrategy string

const (
	LogSinkRequestSchemasSinkDataStrategyBasic LogSinkRequestSchemasSinkDataStrategy = "basic"
)

func (e LogSinkRequestSchemasSinkDataStrategy) ToPointer() *LogSinkRequestSchemasSinkDataStrategy {
	return &e
}

func (e *LogSinkRequestSchemasSinkDataStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "basic":
		*e = LogSinkRequestSchemasSinkDataStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSchemasSinkDataStrategy: %v", v)
	}
}

// LogSinkRequestSchemas2 - Authenticate with a basic http strategy.
type LogSinkRequestSchemas2 struct {
	// Password for basic http authentication.
	Password string `json:"password"`
	// Basic HTTP authentication strategy.
	Strategy LogSinkRequestSchemasSinkDataStrategy `json:"strategy"`
	// Username for basic http authentication.
	User *string `json:"user,omitempty"`
}

func (o *LogSinkRequestSchemas2) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *LogSinkRequestSchemas2) GetStrategy() LogSinkRequestSchemasSinkDataStrategy {
	if o == nil {
		return LogSinkRequestSchemasSinkDataStrategy("")
	}
	return o.Strategy
}

func (o *LogSinkRequestSchemas2) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

// LogSinkRequestSchemasStrategy - No authentication strategy
type LogSinkRequestSchemasStrategy string

const (
	LogSinkRequestSchemasStrategyNone LogSinkRequestSchemasStrategy = "none"
)

func (e LogSinkRequestSchemasStrategy) ToPointer() *LogSinkRequestSchemasStrategy {
	return &e
}

func (e *LogSinkRequestSchemasStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = LogSinkRequestSchemasStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSchemasStrategy: %v", v)
	}
}

// LogSinkRequestSchemas1 - No authentication strategy
type LogSinkRequestSchemas1 struct {
	// No authentication strategy
	Strategy LogSinkRequestSchemasStrategy `json:"strategy"`
}

func (o *LogSinkRequestSchemas1) GetStrategy() LogSinkRequestSchemasStrategy {
	if o == nil {
		return LogSinkRequestSchemasStrategy("")
	}
	return o.Strategy
}

type LogSinkRequestSchemasAuthType string

const (
	LogSinkRequestSchemasAuthTypeLogSinkRequestSchemas1 LogSinkRequestSchemasAuthType = "LogSinkRequest_Schemas_1"
	LogSinkRequestSchemasAuthTypeLogSinkRequestSchemas2 LogSinkRequestSchemasAuthType = "LogSinkRequest_Schemas_2"
	LogSinkRequestSchemasAuthTypeLogSinkRequest3        LogSinkRequestSchemasAuthType = "LogSinkRequest_3"
)

type LogSinkRequestSchemasAuth struct {
	LogSinkRequestSchemas1 *LogSinkRequestSchemas1
	LogSinkRequestSchemas2 *LogSinkRequestSchemas2
	LogSinkRequest3        *LogSinkRequest3

	Type LogSinkRequestSchemasAuthType
}

func CreateLogSinkRequestSchemasAuthLogSinkRequestSchemas1(logSinkRequestSchemas1 LogSinkRequestSchemas1) LogSinkRequestSchemasAuth {
	typ := LogSinkRequestSchemasAuthTypeLogSinkRequestSchemas1

	return LogSinkRequestSchemasAuth{
		LogSinkRequestSchemas1: &logSinkRequestSchemas1,
		Type:                   typ,
	}
}

func CreateLogSinkRequestSchemasAuthLogSinkRequestSchemas2(logSinkRequestSchemas2 LogSinkRequestSchemas2) LogSinkRequestSchemasAuth {
	typ := LogSinkRequestSchemasAuthTypeLogSinkRequestSchemas2

	return LogSinkRequestSchemasAuth{
		LogSinkRequestSchemas2: &logSinkRequestSchemas2,
		Type:                   typ,
	}
}

func CreateLogSinkRequestSchemasAuthLogSinkRequest3(logSinkRequest3 LogSinkRequest3) LogSinkRequestSchemasAuth {
	typ := LogSinkRequestSchemasAuthTypeLogSinkRequest3

	return LogSinkRequestSchemasAuth{
		LogSinkRequest3: &logSinkRequest3,
		Type:            typ,
	}
}

func (u *LogSinkRequestSchemasAuth) UnmarshalJSON(data []byte) error {

	logSinkRequestSchemas1 := LogSinkRequestSchemas1{}
	if err := utils.UnmarshalJSON(data, &logSinkRequestSchemas1, "", true, true); err == nil {
		u.LogSinkRequestSchemas1 = &logSinkRequestSchemas1
		u.Type = LogSinkRequestSchemasAuthTypeLogSinkRequestSchemas1
		return nil
	}

	logSinkRequest3 := LogSinkRequest3{}
	if err := utils.UnmarshalJSON(data, &logSinkRequest3, "", true, true); err == nil {
		u.LogSinkRequest3 = &logSinkRequest3
		u.Type = LogSinkRequestSchemasAuthTypeLogSinkRequest3
		return nil
	}

	logSinkRequestSchemas2 := LogSinkRequestSchemas2{}
	if err := utils.UnmarshalJSON(data, &logSinkRequestSchemas2, "", true, true); err == nil {
		u.LogSinkRequestSchemas2 = &logSinkRequestSchemas2
		u.Type = LogSinkRequestSchemasAuthTypeLogSinkRequestSchemas2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LogSinkRequestSchemasAuth) MarshalJSON() ([]byte, error) {
	if u.LogSinkRequestSchemas1 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSchemas1, "", true)
	}

	if u.LogSinkRequestSchemas2 != nil {
		return utils.MarshalJSON(u.LogSinkRequestSchemas2, "", true)
	}

	if u.LogSinkRequest3 != nil {
		return utils.MarshalJSON(u.LogSinkRequest3, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// LogSinkRequestCodec - Codec to encode logs in
type LogSinkRequestCodec string

const (
	LogSinkRequestCodecText LogSinkRequestCodec = "text"
	LogSinkRequestCodecJSON LogSinkRequestCodec = "json"
)

func (e LogSinkRequestCodec) ToPointer() *LogSinkRequestCodec {
	return &e
}

func (e *LogSinkRequestCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "json":
		*e = LogSinkRequestCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestCodec: %v", v)
	}
}

// LogSinkRequestEncoding - Encoding options
type LogSinkRequestEncoding struct {
	// Codec to encode logs in
	Codec LogSinkRequestCodec `json:"codec"`
}

func (o *LogSinkRequestEncoding) GetCodec() LogSinkRequestCodec {
	if o == nil {
		return LogSinkRequestCodec("")
	}
	return o.Codec
}

// Four - HTTP Sink Schema.
type Four struct {
	Auth LogSinkRequestSchemasAuth `json:"auth"`
	// Encoding options
	Encoding *LogSinkRequestEncoding `json:"encoding,omitempty"`
	// Uri to send logs to.
	URI string `json:"uri"`
}

func (o *Four) GetAuth() LogSinkRequestSchemasAuth {
	if o == nil {
		return LogSinkRequestSchemasAuth{}
	}
	return o.Auth
}

func (o *Four) GetEncoding() *LogSinkRequestEncoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *Four) GetURI() string {
	if o == nil {
		return ""
	}
	return o.URI
}

// LogSinkRequestAuthenticationStrategy - The authentication strategy.
type LogSinkRequestAuthenticationStrategy string

const (
	LogSinkRequestAuthenticationStrategyToken LogSinkRequestAuthenticationStrategy = "token"
)

func (e LogSinkRequestAuthenticationStrategy) ToPointer() *LogSinkRequestAuthenticationStrategy {
	return &e
}

func (e *LogSinkRequestAuthenticationStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "token":
		*e = LogSinkRequestAuthenticationStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestAuthenticationStrategy: %v", v)
	}
}

// LogSinkRequest2 - Authenticate with a token.
type LogSinkRequest2 struct {
	// The authentication strategy.
	AuthenticationStrategy LogSinkRequestAuthenticationStrategy `json:"authenticationStrategy"`
	// The HTTP Token for the Papertrail log destination.
	Token string `json:"token"`
	// The uri for the Papertrail log destination.
	URI string `json:"uri"`
}

func (o *LogSinkRequest2) GetAuthenticationStrategy() LogSinkRequestAuthenticationStrategy {
	if o == nil {
		return LogSinkRequestAuthenticationStrategy("")
	}
	return o.AuthenticationStrategy
}

func (o *LogSinkRequest2) GetToken() string {
	if o == nil {
		return ""
	}
	return o.Token
}

func (o *LogSinkRequest2) GetURI() string {
	if o == nil {
		return ""
	}
	return o.URI
}

// LogSinkRequestSchemasAuthenticationStrategy - The authentication strategy.
type LogSinkRequestSchemasAuthenticationStrategy string

const (
	LogSinkRequestSchemasAuthenticationStrategyPort LogSinkRequestSchemasAuthenticationStrategy = "port"
)

func (e LogSinkRequestSchemasAuthenticationStrategy) ToPointer() *LogSinkRequestSchemasAuthenticationStrategy {
	return &e
}

func (e *LogSinkRequestSchemasAuthenticationStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "port":
		*e = LogSinkRequestSchemasAuthenticationStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestSchemasAuthenticationStrategy: %v", v)
	}
}

// LogSinkRequest1 - Authenticate with a host/port
type LogSinkRequest1 struct {
	// The authentication strategy.
	AuthenticationStrategy LogSinkRequestSchemasAuthenticationStrategy `json:"authenticationStrategy"`
	// The host for the Papertrail log destination.
	Host string `json:"host"`
	// The port for the Papertrail log destination.
	Port float32 `json:"port"`
}

func (o *LogSinkRequest1) GetAuthenticationStrategy() LogSinkRequestSchemasAuthenticationStrategy {
	if o == nil {
		return LogSinkRequestSchemasAuthenticationStrategy("")
	}
	return o.AuthenticationStrategy
}

func (o *LogSinkRequest1) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *LogSinkRequest1) GetPort() float32 {
	if o == nil {
		return 0.0
	}
	return o.Port
}

type ThreeType string

const (
	ThreeTypeLogSinkRequest1 ThreeType = "LogSinkRequest_1"
	ThreeTypeLogSinkRequest2 ThreeType = "LogSinkRequest_2"
)

// Three - Papertrail Sink Schema.
type Three struct {
	LogSinkRequest1 *LogSinkRequest1
	LogSinkRequest2 *LogSinkRequest2

	Type ThreeType
}

func CreateThreeLogSinkRequest1(logSinkRequest1 LogSinkRequest1) Three {
	typ := ThreeTypeLogSinkRequest1

	return Three{
		LogSinkRequest1: &logSinkRequest1,
		Type:            typ,
	}
}

func CreateThreeLogSinkRequest2(logSinkRequest2 LogSinkRequest2) Three {
	typ := ThreeTypeLogSinkRequest2

	return Three{
		LogSinkRequest2: &logSinkRequest2,
		Type:            typ,
	}
}

func (u *Three) UnmarshalJSON(data []byte) error {

	logSinkRequest1 := LogSinkRequest1{}
	if err := utils.UnmarshalJSON(data, &logSinkRequest1, "", true, true); err == nil {
		u.LogSinkRequest1 = &logSinkRequest1
		u.Type = ThreeTypeLogSinkRequest1
		return nil
	}

	logSinkRequest2 := LogSinkRequest2{}
	if err := utils.UnmarshalJSON(data, &logSinkRequest2, "", true, true); err == nil {
		u.LogSinkRequest2 = &logSinkRequest2
		u.Type = ThreeTypeLogSinkRequest2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Three) MarshalJSON() ([]byte, error) {
	if u.LogSinkRequest1 != nil {
		return utils.MarshalJSON(u.LogSinkRequest1, "", true)
	}

	if u.LogSinkRequest2 != nil {
		return utils.MarshalJSON(u.LogSinkRequest2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// LogSinkRequestRegion - The Datadog region.
type LogSinkRequestRegion string

const (
	LogSinkRequestRegionEu  LogSinkRequestRegion = "eu"
	LogSinkRequestRegionUs  LogSinkRequestRegion = "us"
	LogSinkRequestRegionUs3 LogSinkRequestRegion = "us3"
	LogSinkRequestRegionUs5 LogSinkRequestRegion = "us5"
)

func (e LogSinkRequestRegion) ToPointer() *LogSinkRequestRegion {
	return &e
}

func (e *LogSinkRequestRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "us3":
		fallthrough
	case "us5":
		*e = LogSinkRequestRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestRegion: %v", v)
	}
}

// Two - Datadog Sink Schema.
type Two struct {
	// The Datadog API key.
	DefaultAPIKey *string `json:"default_api_key,omitempty"`
	// The Datadog region.
	Region *LogSinkRequestRegion `json:"region,omitempty"`
}

func (o *Two) GetDefaultAPIKey() *string {
	if o == nil {
		return nil
	}
	return o.DefaultAPIKey
}

func (o *Two) GetRegion() *LogSinkRequestRegion {
	if o == nil {
		return nil
	}
	return o.Region
}

// LogSinkRequestStrategy - The authentication method.
type LogSinkRequestStrategy string

const (
	LogSinkRequestStrategyBasic LogSinkRequestStrategy = "basic"
)

func (e LogSinkRequestStrategy) ToPointer() *LogSinkRequestStrategy {
	return &e
}

func (e *LogSinkRequestStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "basic":
		*e = LogSinkRequestStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkRequestStrategy: %v", v)
	}
}

// LogSinkRequestAuth - Object containing authentication data for the log sink.
type LogSinkRequestAuth struct {
	// The password for the log sink.
	Password *string `json:"password,omitempty"`
	// The authentication method.
	Strategy *LogSinkRequestStrategy `json:"strategy,omitempty"`
	// The username for the log sink.
	User *string `json:"user,omitempty"`
}

func (o *LogSinkRequestAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *LogSinkRequestAuth) GetStrategy() *LogSinkRequestStrategy {
	if o == nil {
		return nil
	}
	return o.Strategy
}

func (o *LogSinkRequestAuth) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

// One - Loki Sink Schema.
type One struct {
	// Object containing authentication data for the log sink.
	Auth *LogSinkRequestAuth `json:"auth,omitempty"`
	// The endpoint of the Loki log sink.
	Endpoint *string `json:"endpoint,omitempty"`
}

func (o *One) GetAuth() *LogSinkRequestAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *One) GetEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.Endpoint
}

type LogSinkRequestSinkDataType string

const (
	LogSinkRequestSinkDataTypeOne   LogSinkRequestSinkDataType = "1"
	LogSinkRequestSinkDataTypeTwo   LogSinkRequestSinkDataType = "2"
	LogSinkRequestSinkDataTypeThree LogSinkRequestSinkDataType = "3"
	LogSinkRequestSinkDataTypeFour  LogSinkRequestSinkDataType = "4"
	LogSinkRequestSinkDataTypeFive  LogSinkRequestSinkDataType = "5"
	LogSinkRequestSinkDataTypeSix   LogSinkRequestSinkDataType = "6"
	LogSinkRequestSinkDataTypeSeven LogSinkRequestSinkDataType = "7"
	LogSinkRequestSinkDataTypeEight LogSinkRequestSinkDataType = "8"
)

// LogSinkRequestSinkData - Data about the log sink.
type LogSinkRequestSinkData struct {
	One   *One
	Two   *Two
	Three *Three
	Four  *Four
	Five  *Five
	Six   *Six
	Seven *Seven
	Eight *Eight

	Type LogSinkRequestSinkDataType
}

func CreateLogSinkRequestSinkDataOne(one One) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeOne

	return LogSinkRequestSinkData{
		One:  &one,
		Type: typ,
	}
}

func CreateLogSinkRequestSinkDataTwo(two Two) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeTwo

	return LogSinkRequestSinkData{
		Two:  &two,
		Type: typ,
	}
}

func CreateLogSinkRequestSinkDataThree(three Three) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeThree

	return LogSinkRequestSinkData{
		Three: &three,
		Type:  typ,
	}
}

func CreateLogSinkRequestSinkDataFour(four Four) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeFour

	return LogSinkRequestSinkData{
		Four: &four,
		Type: typ,
	}
}

func CreateLogSinkRequestSinkDataFive(five Five) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeFive

	return LogSinkRequestSinkData{
		Five: &five,
		Type: typ,
	}
}

func CreateLogSinkRequestSinkDataSix(six Six) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeSix

	return LogSinkRequestSinkData{
		Six:  &six,
		Type: typ,
	}
}

func CreateLogSinkRequestSinkDataSeven(seven Seven) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeSeven

	return LogSinkRequestSinkData{
		Seven: &seven,
		Type:  typ,
	}
}

func CreateLogSinkRequestSinkDataEight(eight Eight) LogSinkRequestSinkData {
	typ := LogSinkRequestSinkDataTypeEight

	return LogSinkRequestSinkData{
		Eight: &eight,
		Type:  typ,
	}
}

func (u *LogSinkRequestSinkData) UnmarshalJSON(data []byte) error {

	six := Six{}
	if err := utils.UnmarshalJSON(data, &six, "", true, true); err == nil {
		u.Six = &six
		u.Type = LogSinkRequestSinkDataTypeSix
		return nil
	}

	seven := Seven{}
	if err := utils.UnmarshalJSON(data, &seven, "", true, true); err == nil {
		u.Seven = &seven
		u.Type = LogSinkRequestSinkDataTypeSeven
		return nil
	}

	one := One{}
	if err := utils.UnmarshalJSON(data, &one, "", true, true); err == nil {
		u.One = &one
		u.Type = LogSinkRequestSinkDataTypeOne
		return nil
	}

	two := Two{}
	if err := utils.UnmarshalJSON(data, &two, "", true, true); err == nil {
		u.Two = &two
		u.Type = LogSinkRequestSinkDataTypeTwo
		return nil
	}

	eight := Eight{}
	if err := utils.UnmarshalJSON(data, &eight, "", true, true); err == nil {
		u.Eight = &eight
		u.Type = LogSinkRequestSinkDataTypeEight
		return nil
	}

	four := Four{}
	if err := utils.UnmarshalJSON(data, &four, "", true, true); err == nil {
		u.Four = &four
		u.Type = LogSinkRequestSinkDataTypeFour
		return nil
	}

	five := Five{}
	if err := utils.UnmarshalJSON(data, &five, "", true, true); err == nil {
		u.Five = &five
		u.Type = LogSinkRequestSinkDataTypeFive
		return nil
	}

	three := Three{}
	if err := utils.UnmarshalJSON(data, &three, "", true, true); err == nil {
		u.Three = &three
		u.Type = LogSinkRequestSinkDataTypeThree
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LogSinkRequestSinkData) MarshalJSON() ([]byte, error) {
	if u.One != nil {
		return utils.MarshalJSON(u.One, "", true)
	}

	if u.Two != nil {
		return utils.MarshalJSON(u.Two, "", true)
	}

	if u.Three != nil {
		return utils.MarshalJSON(u.Three, "", true)
	}

	if u.Four != nil {
		return utils.MarshalJSON(u.Four, "", true)
	}

	if u.Five != nil {
		return utils.MarshalJSON(u.Five, "", true)
	}

	if u.Six != nil {
		return utils.MarshalJSON(u.Six, "", true)
	}

	if u.Seven != nil {
		return utils.MarshalJSON(u.Seven, "", true)
	}

	if u.Eight != nil {
		return utils.MarshalJSON(u.Eight, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type LogSinkRequest struct {
	// If `restricted` is `true`, only logs from these projects will be sent to the log sink.
	Projects []string `json:"projects,omitempty"`
	// If `true`, only logs from the projects in `projects` will be sent to the log sink.
	Restricted *bool `json:"restricted,omitempty"`
	// If `true`, and the log sink is currently paused, the log sink will be resumed after updating.
	ResumeLogSink *bool `default:"false" json:"resumeLogSink"`
	// Data about the log sink.
	SinkData *LogSinkRequestSinkData `json:"sinkData,omitempty"`
	// If `true`, we will do additional parsing on your JSON formatted log lines and your extract custom labels
	UseCustomLabels *bool `default:"false" json:"useCustomLabels"`
}

func (l LogSinkRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkRequest) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *LogSinkRequest) GetRestricted() *bool {
	if o == nil {
		return nil
	}
	return o.Restricted
}

func (o *LogSinkRequest) GetResumeLogSink() *bool {
	if o == nil {
		return nil
	}
	return o.ResumeLogSink
}

func (o *LogSinkRequest) GetSinkData() *LogSinkRequestSinkData {
	if o == nil {
		return nil
	}
	return o.SinkData
}

func (o *LogSinkRequest) GetUseCustomLabels() *bool {
	if o == nil {
		return nil
	}
	return o.UseCustomLabels
}
