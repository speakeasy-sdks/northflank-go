// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy-sdks/northflank-go/v3/pkg/utils"
)

// Auth - Authentication object.
type Auth struct {
	// Access key id for the bucket.
	AccessKeyID string `json:"accessKeyId"`
	// Secret access key for the bucket.
	SecretAccessKey string `json:"secretAccessKey"`
}

func (o *Auth) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *Auth) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

// Compression - Log file compression method.
type Compression string

const (
	CompressionGzip Compression = "gzip"
	CompressionNone Compression = "none"
)

func (e Compression) ToPointer() *Compression {
	return &e
}

func (e *Compression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = Compression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Compression: %v", v)
	}
}

// Region of the S3 bucket.
type Region string

const (
	RegionEuWest1    Region = "eu-west-1"
	RegionEuWest2    Region = "eu-west-2"
	RegionEuWest3    Region = "eu-west-3"
	RegionEuCentral1 Region = "eu-central-1"
	RegionEuSouth1   Region = "eu-south-1"
	RegionEuNorth1   Region = "eu-north-1"
	RegionUsWest1    Region = "us-west-1"
	RegionUsWest2    Region = "us-west-2"
	RegionUsEast1    Region = "us-east-1"
	RegionUsEast2    Region = "us-east2"
)

func (e Region) ToPointer() *Region {
	return &e
}

func (e *Region) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east2":
		*e = Region(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Region: %v", v)
	}
}

// SinkData - Details about the AWS S3 log sink.
type SinkData struct {
	// Authentication object.
	Auth *Auth `json:"auth,omitempty"`
	// Name of the S3 Bucket.
	Bucket string `json:"bucket"`
	// Log file compression method.
	Compression Compression `json:"compression"`
	// Endpoint for the AWS S3 or compatible API bucket.
	Endpoint string `json:"endpoint"`
	// Region of the S3 bucket.
	Region Region `json:"region"`
}

func (o *SinkData) GetAuth() *Auth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *SinkData) GetBucket() string {
	if o == nil {
		return ""
	}
	return o.Bucket
}

func (o *SinkData) GetCompression() Compression {
	if o == nil {
		return Compression("")
	}
	return o.Compression
}

func (o *SinkData) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *SinkData) GetRegion() Region {
	if o == nil {
		return Region("")
	}
	return o.Region
}

// SinkType - The type of the log sink.
type SinkType string

const (
	SinkTypeAwsS3 SinkType = "aws_s3"
)

func (e SinkType) ToPointer() *SinkType {
	return &e
}

func (e *SinkType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aws_s3":
		*e = SinkType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SinkType: %v", v)
	}
}

// AWSLogSink - Create a log sink using AWS S3
type AWSLogSink struct {
	// Description of the log sink.
	Description *string `json:"description,omitempty"`
	// If `true` your network access logs will be forwarded with your workload logs
	ForwardAccessLogs *bool `default:"false" json:"forwardAccessLogs"`
	// Name of the log sink.
	Name string `json:"name"`
	// If `restricted` is `true`, only logs from these projects will be sent to the log sink.
	Projects []string `json:"projects,omitempty"`
	// If `true`, only logs from the projects in `projects` will be sent to the log sink.
	Restricted *bool `default:"false" json:"restricted"`
	// Details about the AWS S3 log sink.
	SinkData SinkData `json:"sinkData"`
	// The type of the log sink.
	SinkType SinkType `json:"sinkType"`
	// If `true`, we will do additional parsing on your JSON formatted log lines and your extract custom labels
	UseCustomLabels *bool `default:"false" json:"useCustomLabels"`
}

func (a AWSLogSink) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AWSLogSink) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *AWSLogSink) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *AWSLogSink) GetForwardAccessLogs() *bool {
	if o == nil {
		return nil
	}
	return o.ForwardAccessLogs
}

func (o *AWSLogSink) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *AWSLogSink) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *AWSLogSink) GetRestricted() *bool {
	if o == nil {
		return nil
	}
	return o.Restricted
}

func (o *AWSLogSink) GetSinkData() SinkData {
	if o == nil {
		return SinkData{}
	}
	return o.SinkData
}

func (o *AWSLogSink) GetSinkType() SinkType {
	if o == nil {
		return SinkType("")
	}
	return o.SinkType
}

func (o *AWSLogSink) GetUseCustomLabels() *bool {
	if o == nil {
		return nil
	}
	return o.UseCustomLabels
}
