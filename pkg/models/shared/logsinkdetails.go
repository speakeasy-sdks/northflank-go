// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-sdks/northflank-go/pkg/types"
	"github.com/speakeasy-sdks/northflank-go/pkg/utils"
	"time"
)

// LogSinkDetailsDataSinkData7 - Honeycomb Sink Schema.
type LogSinkDetailsDataSinkData7 struct {
	// Honeycomb API Key
	APIKey string `json:"api_key"`
	// Name of the dataset
	Dataset string `json:"dataset"`
}

func (o *LogSinkDetailsDataSinkData7) GetAPIKey() string {
	if o == nil {
		return ""
	}
	return o.APIKey
}

func (o *LogSinkDetailsDataSinkData7) GetDataset() string {
	if o == nil {
		return ""
	}
	return o.Dataset
}

// LogSinkDetailsDataSinkData6 - LogDNA Sink Schema.
type LogSinkDetailsDataSinkData6 struct {
	// Ingestion Key
	APIKey string `json:"api_key"`
}

func (o *LogSinkDetailsDataSinkData6) GetAPIKey() string {
	if o == nil {
		return ""
	}
	return o.APIKey
}

// LogSinkDetailsDataSinkData5 - Logtail Sink Schema.
type LogSinkDetailsDataSinkData5 struct {
	// Logtail Source Token
	Token string `json:"token"`
}

func (o *LogSinkDetailsDataSinkData5) GetToken() string {
	if o == nil {
		return ""
	}
	return o.Token
}

// LogSinkDetailsDataSinkData4Auth - Authentication object.
type LogSinkDetailsDataSinkData4Auth struct {
	// Access key id for the bucket.
	AccessKeyID string `json:"accessKeyId"`
	// Secret access key for the bucket.
	SecretAccessKey string `json:"secretAccessKey"`
}

func (o *LogSinkDetailsDataSinkData4Auth) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *LogSinkDetailsDataSinkData4Auth) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

// LogSinkDetailsDataSinkData4Compression - Log file compression method.
type LogSinkDetailsDataSinkData4Compression string

const (
	LogSinkDetailsDataSinkData4CompressionGzip LogSinkDetailsDataSinkData4Compression = "gzip"
	LogSinkDetailsDataSinkData4CompressionNone LogSinkDetailsDataSinkData4Compression = "none"
)

func (e LogSinkDetailsDataSinkData4Compression) ToPointer() *LogSinkDetailsDataSinkData4Compression {
	return &e
}

func (e *LogSinkDetailsDataSinkData4Compression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = LogSinkDetailsDataSinkData4Compression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkDetailsDataSinkData4Compression: %v", v)
	}
}

// LogSinkDetailsDataSinkData4Region - Region of the S3 bucket.
type LogSinkDetailsDataSinkData4Region string

const (
	LogSinkDetailsDataSinkData4RegionEuWest1    LogSinkDetailsDataSinkData4Region = "eu-west-1"
	LogSinkDetailsDataSinkData4RegionEuWest2    LogSinkDetailsDataSinkData4Region = "eu-west-2"
	LogSinkDetailsDataSinkData4RegionEuWest3    LogSinkDetailsDataSinkData4Region = "eu-west-3"
	LogSinkDetailsDataSinkData4RegionEuCentral1 LogSinkDetailsDataSinkData4Region = "eu-central-1"
	LogSinkDetailsDataSinkData4RegionEuSouth1   LogSinkDetailsDataSinkData4Region = "eu-south-1"
	LogSinkDetailsDataSinkData4RegionEuNorth1   LogSinkDetailsDataSinkData4Region = "eu-north-1"
	LogSinkDetailsDataSinkData4RegionUsWest1    LogSinkDetailsDataSinkData4Region = "us-west-1"
	LogSinkDetailsDataSinkData4RegionUsWest2    LogSinkDetailsDataSinkData4Region = "us-west-2"
	LogSinkDetailsDataSinkData4RegionUsEast1    LogSinkDetailsDataSinkData4Region = "us-east-1"
	LogSinkDetailsDataSinkData4RegionUsEast2    LogSinkDetailsDataSinkData4Region = "us-east2"
)

func (e LogSinkDetailsDataSinkData4Region) ToPointer() *LogSinkDetailsDataSinkData4Region {
	return &e
}

func (e *LogSinkDetailsDataSinkData4Region) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east2":
		*e = LogSinkDetailsDataSinkData4Region(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkDetailsDataSinkData4Region: %v", v)
	}
}

// LogSinkDetailsDataSinkData4 - AWS S3 or compatible API Sink Schema.
type LogSinkDetailsDataSinkData4 struct {
	// Authentication object.
	Auth *LogSinkDetailsDataSinkData4Auth `json:"auth,omitempty"`
	// Name of the S3 Bucket.
	Bucket string `json:"bucket"`
	// Log file compression method.
	Compression LogSinkDetailsDataSinkData4Compression `json:"compression"`
	// Endpoint for the AWS S3 or compatible API bucket.
	Endpoint string `json:"endpoint"`
	// Region of the S3 bucket.
	Region LogSinkDetailsDataSinkData4Region `json:"region"`
}

func (o *LogSinkDetailsDataSinkData4) GetAuth() *LogSinkDetailsDataSinkData4Auth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *LogSinkDetailsDataSinkData4) GetBucket() string {
	if o == nil {
		return ""
	}
	return o.Bucket
}

func (o *LogSinkDetailsDataSinkData4) GetCompression() LogSinkDetailsDataSinkData4Compression {
	if o == nil {
		return LogSinkDetailsDataSinkData4Compression("")
	}
	return o.Compression
}

func (o *LogSinkDetailsDataSinkData4) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *LogSinkDetailsDataSinkData4) GetRegion() LogSinkDetailsDataSinkData4Region {
	if o == nil {
		return LogSinkDetailsDataSinkData4Region("")
	}
	return o.Region
}

// LogSinkDetailsDataSinkData3Auth3 - Authenticate with a bearer token strategy.
type LogSinkDetailsDataSinkData3Auth3 struct {
	// Bearer token authentication strategy.
	strategy string `const:"bearer" json:"strategy"`
	// Token for bearer token authentication.
	Token *string `json:"token,omitempty"`
}

func (l LogSinkDetailsDataSinkData3Auth3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkDetailsDataSinkData3Auth3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkDetailsDataSinkData3Auth3) GetStrategy() string {
	return "bearer"
}

func (o *LogSinkDetailsDataSinkData3Auth3) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

// LogSinkDetailsDataSinkData3Auth2 - Authenticate with a basic http strategy.
type LogSinkDetailsDataSinkData3Auth2 struct {
	// Password for basic http authentication.
	Password string `json:"password"`
	// Basic HTTP authentication strategy.
	strategy string `const:"basic" json:"strategy"`
	// Username for basic http authentication.
	User *string `json:"user,omitempty"`
}

func (l LogSinkDetailsDataSinkData3Auth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkDetailsDataSinkData3Auth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkDetailsDataSinkData3Auth2) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *LogSinkDetailsDataSinkData3Auth2) GetStrategy() string {
	return "basic"
}

func (o *LogSinkDetailsDataSinkData3Auth2) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

// LogSinkDetailsDataSinkData3Auth1 - No authentication strategy
type LogSinkDetailsDataSinkData3Auth1 struct {
	// No authentication strategy
	strategy string `const:"none" json:"strategy"`
}

func (l LogSinkDetailsDataSinkData3Auth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkDetailsDataSinkData3Auth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkDetailsDataSinkData3Auth1) GetStrategy() string {
	return "none"
}

type LogSinkDetailsDataSinkData3AuthType string

const (
	LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth1 LogSinkDetailsDataSinkData3AuthType = "LogSinkDetails_data_sinkData_3_auth_1"
	LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth2 LogSinkDetailsDataSinkData3AuthType = "LogSinkDetails_data_sinkData_3_auth_2"
	LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth3 LogSinkDetailsDataSinkData3AuthType = "LogSinkDetails_data_sinkData_3_auth_3"
)

type LogSinkDetailsDataSinkData3Auth struct {
	LogSinkDetailsDataSinkData3Auth1 *LogSinkDetailsDataSinkData3Auth1
	LogSinkDetailsDataSinkData3Auth2 *LogSinkDetailsDataSinkData3Auth2
	LogSinkDetailsDataSinkData3Auth3 *LogSinkDetailsDataSinkData3Auth3

	Type LogSinkDetailsDataSinkData3AuthType
}

func CreateLogSinkDetailsDataSinkData3AuthLogSinkDetailsDataSinkData3Auth1(logSinkDetailsDataSinkData3Auth1 LogSinkDetailsDataSinkData3Auth1) LogSinkDetailsDataSinkData3Auth {
	typ := LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth1

	return LogSinkDetailsDataSinkData3Auth{
		LogSinkDetailsDataSinkData3Auth1: &logSinkDetailsDataSinkData3Auth1,
		Type:                             typ,
	}
}

func CreateLogSinkDetailsDataSinkData3AuthLogSinkDetailsDataSinkData3Auth2(logSinkDetailsDataSinkData3Auth2 LogSinkDetailsDataSinkData3Auth2) LogSinkDetailsDataSinkData3Auth {
	typ := LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth2

	return LogSinkDetailsDataSinkData3Auth{
		LogSinkDetailsDataSinkData3Auth2: &logSinkDetailsDataSinkData3Auth2,
		Type:                             typ,
	}
}

func CreateLogSinkDetailsDataSinkData3AuthLogSinkDetailsDataSinkData3Auth3(logSinkDetailsDataSinkData3Auth3 LogSinkDetailsDataSinkData3Auth3) LogSinkDetailsDataSinkData3Auth {
	typ := LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth3

	return LogSinkDetailsDataSinkData3Auth{
		LogSinkDetailsDataSinkData3Auth3: &logSinkDetailsDataSinkData3Auth3,
		Type:                             typ,
	}
}

func (u *LogSinkDetailsDataSinkData3Auth) UnmarshalJSON(data []byte) error {

	logSinkDetailsDataSinkData3Auth1 := new(LogSinkDetailsDataSinkData3Auth1)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData3Auth1, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData3Auth1 = logSinkDetailsDataSinkData3Auth1
		u.Type = LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth1
		return nil
	}

	logSinkDetailsDataSinkData3Auth3 := new(LogSinkDetailsDataSinkData3Auth3)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData3Auth3, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData3Auth3 = logSinkDetailsDataSinkData3Auth3
		u.Type = LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth3
		return nil
	}

	logSinkDetailsDataSinkData3Auth2 := new(LogSinkDetailsDataSinkData3Auth2)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData3Auth2, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData3Auth2 = logSinkDetailsDataSinkData3Auth2
		u.Type = LogSinkDetailsDataSinkData3AuthTypeLogSinkDetailsDataSinkData3Auth2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LogSinkDetailsDataSinkData3Auth) MarshalJSON() ([]byte, error) {
	if u.LogSinkDetailsDataSinkData3Auth1 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData3Auth1, "", true)
	}

	if u.LogSinkDetailsDataSinkData3Auth2 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData3Auth2, "", true)
	}

	if u.LogSinkDetailsDataSinkData3Auth3 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData3Auth3, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// LogSinkDetailsDataSinkData3EncodingCodec - Codec to encode logs in
type LogSinkDetailsDataSinkData3EncodingCodec string

const (
	LogSinkDetailsDataSinkData3EncodingCodecText LogSinkDetailsDataSinkData3EncodingCodec = "text"
	LogSinkDetailsDataSinkData3EncodingCodecJSON LogSinkDetailsDataSinkData3EncodingCodec = "json"
)

func (e LogSinkDetailsDataSinkData3EncodingCodec) ToPointer() *LogSinkDetailsDataSinkData3EncodingCodec {
	return &e
}

func (e *LogSinkDetailsDataSinkData3EncodingCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "json":
		*e = LogSinkDetailsDataSinkData3EncodingCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkDetailsDataSinkData3EncodingCodec: %v", v)
	}
}

// LogSinkDetailsDataSinkData3Encoding - Encoding options
type LogSinkDetailsDataSinkData3Encoding struct {
	// Codec to encode logs in
	Codec LogSinkDetailsDataSinkData3EncodingCodec `json:"codec"`
}

func (o *LogSinkDetailsDataSinkData3Encoding) GetCodec() LogSinkDetailsDataSinkData3EncodingCodec {
	if o == nil {
		return LogSinkDetailsDataSinkData3EncodingCodec("")
	}
	return o.Codec
}

// LogSinkDetailsDataSinkData3 - HTTP Sink Schema.
type LogSinkDetailsDataSinkData3 struct {
	Auth LogSinkDetailsDataSinkData3Auth `json:"auth"`
	// Encoding options
	Encoding *LogSinkDetailsDataSinkData3Encoding `json:"encoding,omitempty"`
	// Uri to send logs to.
	URI string `json:"uri"`
}

func (o *LogSinkDetailsDataSinkData3) GetAuth() LogSinkDetailsDataSinkData3Auth {
	if o == nil {
		return LogSinkDetailsDataSinkData3Auth{}
	}
	return o.Auth
}

func (o *LogSinkDetailsDataSinkData3) GetEncoding() *LogSinkDetailsDataSinkData3Encoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *LogSinkDetailsDataSinkData3) GetURI() string {
	if o == nil {
		return ""
	}
	return o.URI
}

// LogSinkDetailsDataSinkData2Region - The Datadog region.
type LogSinkDetailsDataSinkData2Region string

const (
	LogSinkDetailsDataSinkData2RegionEu  LogSinkDetailsDataSinkData2Region = "eu"
	LogSinkDetailsDataSinkData2RegionUs  LogSinkDetailsDataSinkData2Region = "us"
	LogSinkDetailsDataSinkData2RegionUs3 LogSinkDetailsDataSinkData2Region = "us3"
	LogSinkDetailsDataSinkData2RegionUs5 LogSinkDetailsDataSinkData2Region = "us5"
)

func (e LogSinkDetailsDataSinkData2Region) ToPointer() *LogSinkDetailsDataSinkData2Region {
	return &e
}

func (e *LogSinkDetailsDataSinkData2Region) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "us3":
		fallthrough
	case "us5":
		*e = LogSinkDetailsDataSinkData2Region(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkDetailsDataSinkData2Region: %v", v)
	}
}

// LogSinkDetailsDataSinkData2 - Data about the log sink.
type LogSinkDetailsDataSinkData2 struct {
	// The Datadog API key.
	DefaultAPIKey string `json:"default_api_key"`
	// The Datadog region.
	Region LogSinkDetailsDataSinkData2Region `json:"region"`
}

func (o *LogSinkDetailsDataSinkData2) GetDefaultAPIKey() string {
	if o == nil {
		return ""
	}
	return o.DefaultAPIKey
}

func (o *LogSinkDetailsDataSinkData2) GetRegion() LogSinkDetailsDataSinkData2Region {
	if o == nil {
		return LogSinkDetailsDataSinkData2Region("")
	}
	return o.Region
}

// LogSinkDetailsDataSinkData1Auth - Object containing authentication data for the log sink.
type LogSinkDetailsDataSinkData1Auth struct {
	// The password for the log sink.
	Password *string `json:"password,omitempty"`
	// The authentication strategy.
	strategy *string `const:"basic" json:"strategy,omitempty"`
	// The username for the log sink.
	User *string `json:"user,omitempty"`
}

func (l LogSinkDetailsDataSinkData1Auth) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkDetailsDataSinkData1Auth) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkDetailsDataSinkData1Auth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *LogSinkDetailsDataSinkData1Auth) GetStrategy() *string {
	return types.String("basic")
}

func (o *LogSinkDetailsDataSinkData1Auth) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

// LogSinkDetailsDataSinkData1EncodingCodec - Codec to encode logs in
type LogSinkDetailsDataSinkData1EncodingCodec string

const (
	LogSinkDetailsDataSinkData1EncodingCodecText LogSinkDetailsDataSinkData1EncodingCodec = "text"
	LogSinkDetailsDataSinkData1EncodingCodecJSON LogSinkDetailsDataSinkData1EncodingCodec = "json"
)

func (e LogSinkDetailsDataSinkData1EncodingCodec) ToPointer() *LogSinkDetailsDataSinkData1EncodingCodec {
	return &e
}

func (e *LogSinkDetailsDataSinkData1EncodingCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "json":
		*e = LogSinkDetailsDataSinkData1EncodingCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkDetailsDataSinkData1EncodingCodec: %v", v)
	}
}

// LogSinkDetailsDataSinkData1Encoding - Encoding options
type LogSinkDetailsDataSinkData1Encoding struct {
	// Codec to encode logs in
	Codec LogSinkDetailsDataSinkData1EncodingCodec `json:"codec"`
}

func (o *LogSinkDetailsDataSinkData1Encoding) GetCodec() LogSinkDetailsDataSinkData1EncodingCodec {
	if o == nil {
		return LogSinkDetailsDataSinkData1EncodingCodec("")
	}
	return o.Codec
}

// LogSinkDetailsDataSinkData1 - Data about the log sink.
type LogSinkDetailsDataSinkData1 struct {
	// Object containing authentication data for the log sink.
	Auth *LogSinkDetailsDataSinkData1Auth `json:"auth,omitempty"`
	// Encoding options
	Encoding *LogSinkDetailsDataSinkData1Encoding `json:"encoding,omitempty"`
	// The endpoint of the Loki log sink.
	Endpoint string `json:"endpoint"`
}

func (o *LogSinkDetailsDataSinkData1) GetAuth() *LogSinkDetailsDataSinkData1Auth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *LogSinkDetailsDataSinkData1) GetEncoding() *LogSinkDetailsDataSinkData1Encoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *LogSinkDetailsDataSinkData1) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

type LogSinkDetailsDataSinkDataType string

const (
	LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData1 LogSinkDetailsDataSinkDataType = "LogSinkDetails_data_sinkData_1"
	LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData2 LogSinkDetailsDataSinkDataType = "LogSinkDetails_data_sinkData_2"
	LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData3 LogSinkDetailsDataSinkDataType = "LogSinkDetails_data_sinkData_3"
	LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData4 LogSinkDetailsDataSinkDataType = "LogSinkDetails_data_sinkData_4"
	LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData5 LogSinkDetailsDataSinkDataType = "LogSinkDetails_data_sinkData_5"
	LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData6 LogSinkDetailsDataSinkDataType = "LogSinkDetails_data_sinkData_6"
	LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData7 LogSinkDetailsDataSinkDataType = "LogSinkDetails_data_sinkData_7"
)

type LogSinkDetailsDataSinkData struct {
	LogSinkDetailsDataSinkData1 *LogSinkDetailsDataSinkData1
	LogSinkDetailsDataSinkData2 *LogSinkDetailsDataSinkData2
	LogSinkDetailsDataSinkData3 *LogSinkDetailsDataSinkData3
	LogSinkDetailsDataSinkData4 *LogSinkDetailsDataSinkData4
	LogSinkDetailsDataSinkData5 *LogSinkDetailsDataSinkData5
	LogSinkDetailsDataSinkData6 *LogSinkDetailsDataSinkData6
	LogSinkDetailsDataSinkData7 *LogSinkDetailsDataSinkData7

	Type LogSinkDetailsDataSinkDataType
}

func CreateLogSinkDetailsDataSinkDataLogSinkDetailsDataSinkData1(logSinkDetailsDataSinkData1 LogSinkDetailsDataSinkData1) LogSinkDetailsDataSinkData {
	typ := LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData1

	return LogSinkDetailsDataSinkData{
		LogSinkDetailsDataSinkData1: &logSinkDetailsDataSinkData1,
		Type:                        typ,
	}
}

func CreateLogSinkDetailsDataSinkDataLogSinkDetailsDataSinkData2(logSinkDetailsDataSinkData2 LogSinkDetailsDataSinkData2) LogSinkDetailsDataSinkData {
	typ := LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData2

	return LogSinkDetailsDataSinkData{
		LogSinkDetailsDataSinkData2: &logSinkDetailsDataSinkData2,
		Type:                        typ,
	}
}

func CreateLogSinkDetailsDataSinkDataLogSinkDetailsDataSinkData3(logSinkDetailsDataSinkData3 LogSinkDetailsDataSinkData3) LogSinkDetailsDataSinkData {
	typ := LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData3

	return LogSinkDetailsDataSinkData{
		LogSinkDetailsDataSinkData3: &logSinkDetailsDataSinkData3,
		Type:                        typ,
	}
}

func CreateLogSinkDetailsDataSinkDataLogSinkDetailsDataSinkData4(logSinkDetailsDataSinkData4 LogSinkDetailsDataSinkData4) LogSinkDetailsDataSinkData {
	typ := LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData4

	return LogSinkDetailsDataSinkData{
		LogSinkDetailsDataSinkData4: &logSinkDetailsDataSinkData4,
		Type:                        typ,
	}
}

func CreateLogSinkDetailsDataSinkDataLogSinkDetailsDataSinkData5(logSinkDetailsDataSinkData5 LogSinkDetailsDataSinkData5) LogSinkDetailsDataSinkData {
	typ := LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData5

	return LogSinkDetailsDataSinkData{
		LogSinkDetailsDataSinkData5: &logSinkDetailsDataSinkData5,
		Type:                        typ,
	}
}

func CreateLogSinkDetailsDataSinkDataLogSinkDetailsDataSinkData6(logSinkDetailsDataSinkData6 LogSinkDetailsDataSinkData6) LogSinkDetailsDataSinkData {
	typ := LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData6

	return LogSinkDetailsDataSinkData{
		LogSinkDetailsDataSinkData6: &logSinkDetailsDataSinkData6,
		Type:                        typ,
	}
}

func CreateLogSinkDetailsDataSinkDataLogSinkDetailsDataSinkData7(logSinkDetailsDataSinkData7 LogSinkDetailsDataSinkData7) LogSinkDetailsDataSinkData {
	typ := LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData7

	return LogSinkDetailsDataSinkData{
		LogSinkDetailsDataSinkData7: &logSinkDetailsDataSinkData7,
		Type:                        typ,
	}
}

func (u *LogSinkDetailsDataSinkData) UnmarshalJSON(data []byte) error {

	logSinkDetailsDataSinkData5 := new(LogSinkDetailsDataSinkData5)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData5, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData5 = logSinkDetailsDataSinkData5
		u.Type = LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData5
		return nil
	}

	logSinkDetailsDataSinkData6 := new(LogSinkDetailsDataSinkData6)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData6, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData6 = logSinkDetailsDataSinkData6
		u.Type = LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData6
		return nil
	}

	logSinkDetailsDataSinkData2 := new(LogSinkDetailsDataSinkData2)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData2, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData2 = logSinkDetailsDataSinkData2
		u.Type = LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData2
		return nil
	}

	logSinkDetailsDataSinkData7 := new(LogSinkDetailsDataSinkData7)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData7, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData7 = logSinkDetailsDataSinkData7
		u.Type = LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData7
		return nil
	}

	logSinkDetailsDataSinkData1 := new(LogSinkDetailsDataSinkData1)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData1, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData1 = logSinkDetailsDataSinkData1
		u.Type = LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData1
		return nil
	}

	logSinkDetailsDataSinkData3 := new(LogSinkDetailsDataSinkData3)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData3, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData3 = logSinkDetailsDataSinkData3
		u.Type = LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData3
		return nil
	}

	logSinkDetailsDataSinkData4 := new(LogSinkDetailsDataSinkData4)
	if err := utils.UnmarshalJSON(data, &logSinkDetailsDataSinkData4, "", true, true); err == nil {
		u.LogSinkDetailsDataSinkData4 = logSinkDetailsDataSinkData4
		u.Type = LogSinkDetailsDataSinkDataTypeLogSinkDetailsDataSinkData4
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LogSinkDetailsDataSinkData) MarshalJSON() ([]byte, error) {
	if u.LogSinkDetailsDataSinkData1 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData1, "", true)
	}

	if u.LogSinkDetailsDataSinkData2 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData2, "", true)
	}

	if u.LogSinkDetailsDataSinkData3 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData3, "", true)
	}

	if u.LogSinkDetailsDataSinkData4 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData4, "", true)
	}

	if u.LogSinkDetailsDataSinkData5 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData5, "", true)
	}

	if u.LogSinkDetailsDataSinkData6 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData6, "", true)
	}

	if u.LogSinkDetailsDataSinkData7 != nil {
		return utils.MarshalJSON(u.LogSinkDetailsDataSinkData7, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// LogSinkDetailsDataSinkType - The type of the log sink.
type LogSinkDetailsDataSinkType string

const (
	LogSinkDetailsDataSinkTypeLoki        LogSinkDetailsDataSinkType = "loki"
	LogSinkDetailsDataSinkTypeDatadogLogs LogSinkDetailsDataSinkType = "datadog_logs"
	LogSinkDetailsDataSinkTypePapertrail  LogSinkDetailsDataSinkType = "papertrail"
	LogSinkDetailsDataSinkTypeHTTP        LogSinkDetailsDataSinkType = "http"
	LogSinkDetailsDataSinkTypeAwsS3       LogSinkDetailsDataSinkType = "aws_s3"
	LogSinkDetailsDataSinkTypeLogdna      LogSinkDetailsDataSinkType = "logdna"
	LogSinkDetailsDataSinkTypeCoralogix   LogSinkDetailsDataSinkType = "coralogix"
	LogSinkDetailsDataSinkTypeLogtail     LogSinkDetailsDataSinkType = "logtail"
	LogSinkDetailsDataSinkTypeHoneycomb   LogSinkDetailsDataSinkType = "honeycomb"
	LogSinkDetailsDataSinkTypeLogzio      LogSinkDetailsDataSinkType = "logzio"
)

func (e LogSinkDetailsDataSinkType) ToPointer() *LogSinkDetailsDataSinkType {
	return &e
}

func (e *LogSinkDetailsDataSinkType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "loki":
		fallthrough
	case "datadog_logs":
		fallthrough
	case "papertrail":
		fallthrough
	case "http":
		fallthrough
	case "aws_s3":
		fallthrough
	case "logdna":
		fallthrough
	case "coralogix":
		fallthrough
	case "logtail":
		fallthrough
	case "honeycomb":
		fallthrough
	case "logzio":
		*e = LogSinkDetailsDataSinkType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogSinkDetailsDataSinkType: %v", v)
	}
}

// LogSinkDetailsData - Result data.
type LogSinkDetailsData struct {
	// Timestamp of when the log sink was created.
	CreatedAt time.Time `json:"createdAt"`
	// Description of the log sink.
	Description *string `json:"description,omitempty"`
	// Identifier for the Log Sink
	ID string `json:"id"`
	// Name of the log sink.
	Name string `json:"name"`
	// If `restricted` is `true`, only logs from these projects will be sent to the log sink.
	Projects []string `json:"projects"`
	// If `true`, only logs from the projects in `projects` will be sent to the log sink.
	Restricted bool `json:"restricted"`
	// Data about the log sink.
	SinkData *LogSinkDetailsDataSinkData `json:"sinkData,omitempty"`
	// The type of the log sink.
	SinkType LogSinkDetailsDataSinkType `json:"sinkType"`
	// Timestamp of when the log sink was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
	// If `true`, we will do additional parsing on your JSON formatted log lines and your extract custom labels
	UseCustomLabels *bool `default:"false" json:"useCustomLabels"`
}

func (l LogSinkDetailsData) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogSinkDetailsData) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *LogSinkDetailsData) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *LogSinkDetailsData) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *LogSinkDetailsData) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *LogSinkDetailsData) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *LogSinkDetailsData) GetProjects() []string {
	if o == nil {
		return []string{}
	}
	return o.Projects
}

func (o *LogSinkDetailsData) GetRestricted() bool {
	if o == nil {
		return false
	}
	return o.Restricted
}

func (o *LogSinkDetailsData) GetSinkData() *LogSinkDetailsDataSinkData {
	if o == nil {
		return nil
	}
	return o.SinkData
}

func (o *LogSinkDetailsData) GetSinkType() LogSinkDetailsDataSinkType {
	if o == nil {
		return LogSinkDetailsDataSinkType("")
	}
	return o.SinkType
}

func (o *LogSinkDetailsData) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *LogSinkDetailsData) GetUseCustomLabels() *bool {
	if o == nil {
		return nil
	}
	return o.UseCustomLabels
}

// LogSinkDetails - Response object.
type LogSinkDetails struct {
	// Result data.
	Data LogSinkDetailsData `json:"data"`
}

func (o *LogSinkDetails) GetData() LogSinkDetailsData {
	if o == nil {
		return LogSinkDetailsData{}
	}
	return o.Data
}
