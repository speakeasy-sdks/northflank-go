// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-sdks/northflank-go/v2/pkg/utils"
)

// HTTPLogSinkSchemasStrategy - Bearer token authentication strategy.
type HTTPLogSinkSchemasStrategy string

const (
	HTTPLogSinkSchemasStrategyBearer HTTPLogSinkSchemasStrategy = "bearer"
)

func (e HTTPLogSinkSchemasStrategy) ToPointer() *HTTPLogSinkSchemasStrategy {
	return &e
}

func (e *HTTPLogSinkSchemasStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bearer":
		*e = HTTPLogSinkSchemasStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HTTPLogSinkSchemasStrategy: %v", v)
	}
}

// HTTPLogSink3 - Authenticate with a bearer token strategy.
type HTTPLogSink3 struct {
	// Bearer token authentication strategy.
	Strategy HTTPLogSinkSchemasStrategy `json:"strategy"`
	// Token for bearer token authentication.
	Token *string `json:"token,omitempty"`
}

func (o *HTTPLogSink3) GetStrategy() HTTPLogSinkSchemasStrategy {
	if o == nil {
		return HTTPLogSinkSchemasStrategy("")
	}
	return o.Strategy
}

func (o *HTTPLogSink3) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

// HTTPLogSinkStrategy - Basic HTTP authentication strategy.
type HTTPLogSinkStrategy string

const (
	HTTPLogSinkStrategyBasic HTTPLogSinkStrategy = "basic"
)

func (e HTTPLogSinkStrategy) ToPointer() *HTTPLogSinkStrategy {
	return &e
}

func (e *HTTPLogSinkStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "basic":
		*e = HTTPLogSinkStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HTTPLogSinkStrategy: %v", v)
	}
}

// HTTPLogSink2 - Authenticate with a basic http strategy.
type HTTPLogSink2 struct {
	// Password for basic http authentication.
	Password string `json:"password"`
	// Basic HTTP authentication strategy.
	Strategy HTTPLogSinkStrategy `json:"strategy"`
	// Username for basic http authentication.
	User *string `json:"user,omitempty"`
}

func (o *HTTPLogSink2) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *HTTPLogSink2) GetStrategy() HTTPLogSinkStrategy {
	if o == nil {
		return HTTPLogSinkStrategy("")
	}
	return o.Strategy
}

func (o *HTTPLogSink2) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

// HTTPLogSinkSchemasSinkDataStrategy - No authentication strategy
type HTTPLogSinkSchemasSinkDataStrategy string

const (
	HTTPLogSinkSchemasSinkDataStrategyNone HTTPLogSinkSchemasSinkDataStrategy = "none"
)

func (e HTTPLogSinkSchemasSinkDataStrategy) ToPointer() *HTTPLogSinkSchemasSinkDataStrategy {
	return &e
}

func (e *HTTPLogSinkSchemasSinkDataStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = HTTPLogSinkSchemasSinkDataStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HTTPLogSinkSchemasSinkDataStrategy: %v", v)
	}
}

// HTTPLogSink1 - No authentication strategy
type HTTPLogSink1 struct {
	// No authentication strategy
	Strategy HTTPLogSinkSchemasSinkDataStrategy `json:"strategy"`
}

func (o *HTTPLogSink1) GetStrategy() HTTPLogSinkSchemasSinkDataStrategy {
	if o == nil {
		return HTTPLogSinkSchemasSinkDataStrategy("")
	}
	return o.Strategy
}

type HTTPLogSinkAuthType string

const (
	HTTPLogSinkAuthTypeHTTPLogSink1 HTTPLogSinkAuthType = "HTTPLogSink_1"
	HTTPLogSinkAuthTypeHTTPLogSink2 HTTPLogSinkAuthType = "HTTPLogSink_2"
	HTTPLogSinkAuthTypeHTTPLogSink3 HTTPLogSinkAuthType = "HTTPLogSink_3"
)

type HTTPLogSinkAuth struct {
	HTTPLogSink1 *HTTPLogSink1
	HTTPLogSink2 *HTTPLogSink2
	HTTPLogSink3 *HTTPLogSink3

	Type HTTPLogSinkAuthType
}

func CreateHTTPLogSinkAuthHTTPLogSink1(httpLogSink1 HTTPLogSink1) HTTPLogSinkAuth {
	typ := HTTPLogSinkAuthTypeHTTPLogSink1

	return HTTPLogSinkAuth{
		HTTPLogSink1: &httpLogSink1,
		Type:         typ,
	}
}

func CreateHTTPLogSinkAuthHTTPLogSink2(httpLogSink2 HTTPLogSink2) HTTPLogSinkAuth {
	typ := HTTPLogSinkAuthTypeHTTPLogSink2

	return HTTPLogSinkAuth{
		HTTPLogSink2: &httpLogSink2,
		Type:         typ,
	}
}

func CreateHTTPLogSinkAuthHTTPLogSink3(httpLogSink3 HTTPLogSink3) HTTPLogSinkAuth {
	typ := HTTPLogSinkAuthTypeHTTPLogSink3

	return HTTPLogSinkAuth{
		HTTPLogSink3: &httpLogSink3,
		Type:         typ,
	}
}

func (u *HTTPLogSinkAuth) UnmarshalJSON(data []byte) error {

	httpLogSink1 := HTTPLogSink1{}
	if err := utils.UnmarshalJSON(data, &httpLogSink1, "", true, true); err == nil {
		u.HTTPLogSink1 = &httpLogSink1
		u.Type = HTTPLogSinkAuthTypeHTTPLogSink1
		return nil
	}

	httpLogSink3 := HTTPLogSink3{}
	if err := utils.UnmarshalJSON(data, &httpLogSink3, "", true, true); err == nil {
		u.HTTPLogSink3 = &httpLogSink3
		u.Type = HTTPLogSinkAuthTypeHTTPLogSink3
		return nil
	}

	httpLogSink2 := HTTPLogSink2{}
	if err := utils.UnmarshalJSON(data, &httpLogSink2, "", true, true); err == nil {
		u.HTTPLogSink2 = &httpLogSink2
		u.Type = HTTPLogSinkAuthTypeHTTPLogSink2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u HTTPLogSinkAuth) MarshalJSON() ([]byte, error) {
	if u.HTTPLogSink1 != nil {
		return utils.MarshalJSON(u.HTTPLogSink1, "", true)
	}

	if u.HTTPLogSink2 != nil {
		return utils.MarshalJSON(u.HTTPLogSink2, "", true)
	}

	if u.HTTPLogSink3 != nil {
		return utils.MarshalJSON(u.HTTPLogSink3, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// Codec to encode logs in
type Codec string

const (
	CodecText Codec = "text"
	CodecJSON Codec = "json"
)

func (e Codec) ToPointer() *Codec {
	return &e
}

func (e *Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "json":
		*e = Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Codec: %v", v)
	}
}

// Encoding options
type Encoding struct {
	// Codec to encode logs in
	Codec Codec `json:"codec"`
}

func (o *Encoding) GetCodec() Codec {
	if o == nil {
		return Codec("")
	}
	return o.Codec
}

// HTTPLogSinkSinkData - Details about the HTTP log sink.
type HTTPLogSinkSinkData struct {
	Auth HTTPLogSinkAuth `json:"auth"`
	// Encoding options
	Encoding *Encoding `json:"encoding,omitempty"`
	// Uri to send logs to.
	URI string `json:"uri"`
}

func (o *HTTPLogSinkSinkData) GetAuth() HTTPLogSinkAuth {
	if o == nil {
		return HTTPLogSinkAuth{}
	}
	return o.Auth
}

func (o *HTTPLogSinkSinkData) GetEncoding() *Encoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *HTTPLogSinkSinkData) GetURI() string {
	if o == nil {
		return ""
	}
	return o.URI
}

// HTTPLogSinkSinkType - The type of the log sink.
type HTTPLogSinkSinkType string

const (
	HTTPLogSinkSinkTypeHTTP HTTPLogSinkSinkType = "http"
)

func (e HTTPLogSinkSinkType) ToPointer() *HTTPLogSinkSinkType {
	return &e
}

func (e *HTTPLogSinkSinkType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = HTTPLogSinkSinkType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HTTPLogSinkSinkType: %v", v)
	}
}

// HTTPLogSink - Create a log sink using HTTP
type HTTPLogSink struct {
	// Description of the log sink.
	Description *string `json:"description,omitempty"`
	// If `true` your network access logs will be forwarded with your workload logs
	ForwardAccessLogs *bool `default:"false" json:"forwardAccessLogs"`
	// Name of the log sink.
	Name string `json:"name"`
	// If `restricted` is `true`, only logs from these projects will be sent to the log sink.
	Projects []string `json:"projects,omitempty"`
	// If `true`, only logs from the projects in `projects` will be sent to the log sink.
	Restricted *bool `default:"false" json:"restricted"`
	// Details about the HTTP log sink.
	SinkData HTTPLogSinkSinkData `json:"sinkData"`
	// The type of the log sink.
	SinkType HTTPLogSinkSinkType `json:"sinkType"`
	// If `true`, we will do additional parsing on your JSON formatted log lines and your extract custom labels
	UseCustomLabels *bool `default:"false" json:"useCustomLabels"`
}

func (h HTTPLogSink) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(h, "", false)
}

func (h *HTTPLogSink) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &h, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *HTTPLogSink) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *HTTPLogSink) GetForwardAccessLogs() *bool {
	if o == nil {
		return nil
	}
	return o.ForwardAccessLogs
}

func (o *HTTPLogSink) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *HTTPLogSink) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *HTTPLogSink) GetRestricted() *bool {
	if o == nil {
		return nil
	}
	return o.Restricted
}

func (o *HTTPLogSink) GetSinkData() HTTPLogSinkSinkData {
	if o == nil {
		return HTTPLogSinkSinkData{}
	}
	return o.SinkData
}

func (o *HTTPLogSink) GetSinkType() HTTPLogSinkSinkType {
	if o == nil {
		return HTTPLogSinkSinkType("")
	}
	return o.SinkType
}

func (o *HTTPLogSink) GetUseCustomLabels() *bool {
	if o == nil {
		return nil
	}
	return o.UseCustomLabels
}
