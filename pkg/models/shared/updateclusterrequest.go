// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-sdks/northflank-go/v2/pkg/utils"
)

// UpdateClusterRequestAutoscaling - Auto scaling settings to use for the node pool. Requires that the cloud provider supports this feature.
type UpdateClusterRequestAutoscaling struct {
	Enabled *bool  `default:"false" json:"enabled"`
	Max     *int64 `json:"max,omitempty"`
	Min     *int64 `json:"min,omitempty"`
}

func (u UpdateClusterRequestAutoscaling) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateClusterRequestAutoscaling) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *UpdateClusterRequestAutoscaling) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *UpdateClusterRequestAutoscaling) GetMax() *int64 {
	if o == nil {
		return nil
	}
	return o.Max
}

func (o *UpdateClusterRequestAutoscaling) GetMin() *int64 {
	if o == nil {
		return nil
	}
	return o.Min
}

// UpdateClusterRequestLabels - Set of label keys and values that can be used to determine scheduling via resource tags.
type UpdateClusterRequestLabels struct {
}

type UpdateClusterRequestNodePools struct {
	// Auto scaling settings to use for the node pool. Requires that the cloud provider supports this feature.
	Autoscaling *UpdateClusterRequestAutoscaling `json:"autoscaling,omitempty"`
	// Zones in which the node pool should be provisioned.
	AvailabilityZones []string `json:"availabilityZones,omitempty"`
	// Disk size in GB
	DiskSize int64 `json:"diskSize"`
	// The disk type to use.
	DiskType *string `json:"diskType,omitempty"`
	// ID of existing node pool. Must be passed when modifying existing node pools. Not relevant for new node pools
	ID *string `json:"id,omitempty"`
	// Set of label keys and values that can be used to determine scheduling via resource tags.
	Labels *UpdateClusterRequestLabels `json:"labels,omitempty"`
	// Number of nodes to the node pool should be provisioned with.
	NodeCount int64 `json:"nodeCount"`
	// Machine type to be used by the node pool.
	NodeType string `json:"nodeType"`
	// Configures node pool with preemptible / spot instances if enabled.
	Preemptible *bool `default:"false" json:"preemptible"`
	// When 'provider' is 'azure', at least one system node pool is required per cluster.
	SystemPool *bool `json:"systemPool,omitempty"`
}

func (u UpdateClusterRequestNodePools) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateClusterRequestNodePools) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *UpdateClusterRequestNodePools) GetAutoscaling() *UpdateClusterRequestAutoscaling {
	if o == nil {
		return nil
	}
	return o.Autoscaling
}

func (o *UpdateClusterRequestNodePools) GetAvailabilityZones() []string {
	if o == nil {
		return nil
	}
	return o.AvailabilityZones
}

func (o *UpdateClusterRequestNodePools) GetDiskSize() int64 {
	if o == nil {
		return 0
	}
	return o.DiskSize
}

func (o *UpdateClusterRequestNodePools) GetDiskType() *string {
	if o == nil {
		return nil
	}
	return o.DiskType
}

func (o *UpdateClusterRequestNodePools) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *UpdateClusterRequestNodePools) GetLabels() *UpdateClusterRequestLabels {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *UpdateClusterRequestNodePools) GetNodeCount() int64 {
	if o == nil {
		return 0
	}
	return o.NodeCount
}

func (o *UpdateClusterRequestNodePools) GetNodeType() string {
	if o == nil {
		return ""
	}
	return o.NodeType
}

func (o *UpdateClusterRequestNodePools) GetPreemptible() *bool {
	if o == nil {
		return nil
	}
	return o.Preemptible
}

func (o *UpdateClusterRequestNodePools) GetSystemPool() *bool {
	if o == nil {
		return nil
	}
	return o.SystemPool
}

type UpdateClusterRequestMode string

const (
	UpdateClusterRequestModePaas         UpdateClusterRequestMode = "paas"
	UpdateClusterRequestModeInternal     UpdateClusterRequestMode = "internal"
	UpdateClusterRequestModeBuildCluster UpdateClusterRequestMode = "build-cluster"
)

func (e UpdateClusterRequestMode) ToPointer() *UpdateClusterRequestMode {
	return &e
}

func (e *UpdateClusterRequestMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "paas":
		fallthrough
	case "internal":
		fallthrough
	case "build-cluster":
		*e = UpdateClusterRequestMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateClusterRequestMode: %v", v)
	}
}

type UpdateClusterRequestBuilds struct {
	// Cluster to use for scheduling builds
	ClusterID *string                   `json:"clusterId,omitempty"`
	Mode      *UpdateClusterRequestMode `json:"mode,omitempty"`
	// Plan to use for builds if they are run on the cluster
	Plan *string `json:"plan,omitempty"`
}

func (o *UpdateClusterRequestBuilds) GetClusterID() *string {
	if o == nil {
		return nil
	}
	return o.ClusterID
}

func (o *UpdateClusterRequestBuilds) GetMode() *UpdateClusterRequestMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *UpdateClusterRequestBuilds) GetPlan() *string {
	if o == nil {
		return nil
	}
	return o.Plan
}

type UpdateClusterRequest2 struct {
}

type UpdateClusterRequest1 struct {
	S3AccessKey  string `json:"s3AccessKey"`
	S3BucketName string `json:"s3BucketName"`
	S3Region     string `json:"s3Region"`
	S3SecretKey  string `json:"s3SecretKey"`
}

func (o *UpdateClusterRequest1) GetS3AccessKey() string {
	if o == nil {
		return ""
	}
	return o.S3AccessKey
}

func (o *UpdateClusterRequest1) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *UpdateClusterRequest1) GetS3Region() string {
	if o == nil {
		return ""
	}
	return o.S3Region
}

func (o *UpdateClusterRequest1) GetS3SecretKey() string {
	if o == nil {
		return ""
	}
	return o.S3SecretKey
}

type UpdateClusterRequestLokiType string

const (
	UpdateClusterRequestLokiTypeUpdateClusterRequest1 UpdateClusterRequestLokiType = "UpdateClusterRequest_1"
	UpdateClusterRequestLokiTypeUpdateClusterRequest2 UpdateClusterRequestLokiType = "UpdateClusterRequest_2"
)

type UpdateClusterRequestLoki struct {
	UpdateClusterRequest1 *UpdateClusterRequest1
	UpdateClusterRequest2 *UpdateClusterRequest2

	Type UpdateClusterRequestLokiType
}

func CreateUpdateClusterRequestLokiUpdateClusterRequest1(updateClusterRequest1 UpdateClusterRequest1) UpdateClusterRequestLoki {
	typ := UpdateClusterRequestLokiTypeUpdateClusterRequest1

	return UpdateClusterRequestLoki{
		UpdateClusterRequest1: &updateClusterRequest1,
		Type:                  typ,
	}
}

func CreateUpdateClusterRequestLokiUpdateClusterRequest2(updateClusterRequest2 UpdateClusterRequest2) UpdateClusterRequestLoki {
	typ := UpdateClusterRequestLokiTypeUpdateClusterRequest2

	return UpdateClusterRequestLoki{
		UpdateClusterRequest2: &updateClusterRequest2,
		Type:                  typ,
	}
}

func (u *UpdateClusterRequestLoki) UnmarshalJSON(data []byte) error {

	updateClusterRequest2 := UpdateClusterRequest2{}
	if err := utils.UnmarshalJSON(data, &updateClusterRequest2, "", true, true); err == nil {
		u.UpdateClusterRequest2 = &updateClusterRequest2
		u.Type = UpdateClusterRequestLokiTypeUpdateClusterRequest2
		return nil
	}

	updateClusterRequest1 := UpdateClusterRequest1{}
	if err := utils.UnmarshalJSON(data, &updateClusterRequest1, "", true, true); err == nil {
		u.UpdateClusterRequest1 = &updateClusterRequest1
		u.Type = UpdateClusterRequestLokiTypeUpdateClusterRequest1
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UpdateClusterRequestLoki) MarshalJSON() ([]byte, error) {
	if u.UpdateClusterRequest1 != nil {
		return utils.MarshalJSON(u.UpdateClusterRequest1, "", true)
	}

	if u.UpdateClusterRequest2 != nil {
		return utils.MarshalJSON(u.UpdateClusterRequest2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type UpdateClusterRequestSchemasMode string

const (
	UpdateClusterRequestSchemasModePaas UpdateClusterRequestSchemasMode = "paas"
	UpdateClusterRequestSchemasModeLoki UpdateClusterRequestSchemasMode = "loki"
)

func (e UpdateClusterRequestSchemasMode) ToPointer() *UpdateClusterRequestSchemasMode {
	return &e
}

func (e *UpdateClusterRequestSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "paas":
		fallthrough
	case "loki":
		*e = UpdateClusterRequestSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateClusterRequestSchemasMode: %v", v)
	}
}

type UpdateClusterRequestLogging struct {
	Loki *UpdateClusterRequestLoki        `json:"loki,omitempty"`
	Mode *UpdateClusterRequestSchemasMode `json:"mode,omitempty"`
}

func (o *UpdateClusterRequestLogging) GetLoki() *UpdateClusterRequestLoki {
	if o == nil {
		return nil
	}
	return o.Loki
}

func (o *UpdateClusterRequestLogging) GetMode() *UpdateClusterRequestSchemasMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

type UpdateClusterRequestSchemasSettingsMode string

const (
	UpdateClusterRequestSchemasSettingsModePaas       UpdateClusterRequestSchemasSettingsMode = "paas"
	UpdateClusterRequestSchemasSettingsModeSelfHosted UpdateClusterRequestSchemasSettingsMode = "self-hosted"
)

func (e UpdateClusterRequestSchemasSettingsMode) ToPointer() *UpdateClusterRequestSchemasSettingsMode {
	return &e
}

func (e *UpdateClusterRequestSchemasSettingsMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "paas":
		fallthrough
	case "self-hosted":
		*e = UpdateClusterRequestSchemasSettingsMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateClusterRequestSchemasSettingsMode: %v", v)
	}
}

type UpdateClusterRequestRegistry struct {
	Mode *UpdateClusterRequestSchemasSettingsMode `json:"mode,omitempty"`
	// Credentials to use for storing of images.
	RegistryID *string `json:"registryId,omitempty"`
}

func (o *UpdateClusterRequestRegistry) GetMode() *UpdateClusterRequestSchemasSettingsMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *UpdateClusterRequestRegistry) GetRegistryID() *string {
	if o == nil {
		return nil
	}
	return o.RegistryID
}

type UpdateClusterRequestSettings struct {
	Builds   *UpdateClusterRequestBuilds   `json:"builds,omitempty"`
	Logging  *UpdateClusterRequestLogging  `json:"logging,omitempty"`
	Registry *UpdateClusterRequestRegistry `json:"registry,omitempty"`
}

func (o *UpdateClusterRequestSettings) GetBuilds() *UpdateClusterRequestBuilds {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *UpdateClusterRequestSettings) GetLogging() *UpdateClusterRequestLogging {
	if o == nil {
		return nil
	}
	return o.Logging
}

func (o *UpdateClusterRequestSettings) GetRegistry() *UpdateClusterRequestRegistry {
	if o == nil {
		return nil
	}
	return o.Registry
}

type UpdateClusterRequest struct {
	// The description of the cluster.
	Description *string                         `json:"description,omitempty"`
	NodePools   []UpdateClusterRequestNodePools `json:"nodePools,omitempty"`
	Settings    *UpdateClusterRequestSettings   `json:"settings,omitempty"`
}

func (o *UpdateClusterRequest) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *UpdateClusterRequest) GetNodePools() []UpdateClusterRequestNodePools {
	if o == nil {
		return nil
	}
	return o.NodePools
}

func (o *UpdateClusterRequest) GetSettings() *UpdateClusterRequestSettings {
	if o == nil {
		return nil
	}
	return o.Settings
}
